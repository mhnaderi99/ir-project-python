انگشتی|چپ|زبان اسمبلی موتورولا ۶۸۰۰
زبان اَسمبلی  یا همگذاریواژهٔ مصوب فرهنگستان زبان و ادب فارسی، دفتر نخست تا چهارم، ۱۳۷۶ تا ۸۵ یک زبان برنامه‌نویسی سطح پایین برای رایانه‌ها و دیگر دستگاه‌های برنامه‌پذیر است که رابطهٔ یک-به-یک با دستورالعمل‌های زبان ماشین معماری رایانه دارد. هر زبان اسمبلی مختص به یک معماری رایانه خاص است، برخلاف بیشتر زبان‌های برنامه‌نویسی سطح بالا که با معماری‌های مختلف سازگار هستند ولی برای اجرا شدن به مفسر و مترجم نیاز دارند.

زبان اسمبلی با استفاده از یک برنامه جانبی به نام اسمبلر یا همگذار، به کد ماشین قابل اجرا تبدیل می‌شود؛ به این فرایند تبدیل، اسمبل کردن  گفته می‌شود.

زبان اسمبلی از یادیارها برای نشان دادن هر دستور ماشین سطح-پایین یا آپ‌کد استفاده می‌کند. بعضی آپ‌کدها به یک یا چند عملوند به عنوان بخشی از دستورالعمل نیاز دارند و بیشتر اسمبلرها می‌توانند لیبل‌ها و نمادهایی را به عنوان عملوند، برای نشان دادن آدرس‌های حافظه و ثابت‌های عددی بپذیرند. ماکرو اسمبلرها نیز قابلیت درشت‌دستوری  را شامل می‌شوند که این امکان را به وجود می‌آورد که متن یک کد زبان اسمبلی با یک نام از پیش تعیین شده در خلال متن یک کد دیگر استفاده شود. بیشتر اسمبلرها مکانیزم‌های اضافی برای تسهیل فرایند توسعهٔ برنامه، کنترل فرایند اسمبل کردن و پشتیبانی از اشکال‌زدایی ارائه کرده‌اند.

 اسمبلر 
اسمبلر برنامه‌ای است که با تبدیل یادیارهای دستوری اسمبلی  به آپ‌کدها و جایگزینی شناسه‌ها با آدرس‌های حافظه، کد هدف  را به وجود می‌آورد. استفاده از ارجاعات نمادی از ویژگی‌های کلیدی اسمبلرها است که از محاسبات خسته‌کننده و به‌روزرسانی‌های دستی آدرس‌ها بعد از تغییر کد برنامه توسط برنامه‌نویس جلوگیری می‌کند. بیشتر اسمبلرها از قابلیت ماکرو نیز بهره می‌برند که این امکان را به وجود می‌آورد تا یک نام خاص برای یک تکه کد مشخص شود و سپس از آن نام در قسمت‌های مختلف برنامه استفاده شود و در هنگام اسمبل کردن برنامه تکه کد مربوطه جایگزین نام آن شود؛ به عنوان مثال از این روش برای تولید توالی‌های دستوری کوتاه رایج در خلال متن برنامه به جای فراخوانی رویه‌ها استفاده می‌شود.

اسمبلرها از دههٔ ۱۹۵۰ مورد استفاده قرار گرفتند و نوشتن آنها بسیار راحت‌تر از نوشتن مترجم‌ها برای زبان‌های برنامه‌نویسی سطح بالا است به طوری که هر دستور یادیاری و هر آدرس حالت ترکیبی این زبان مستقیماً به یک آپ‌کد زبان ماشین تبدیل می‌شود. اسمبلرهای جدید، به‌طور خاص برای معماری‌های ریسک، مانند اسپارک و پاور، همانند معماری ایکس۸۶ و ایکس۸۶–۶۴، با بهینه‌سازی زمان‌بندی دستورالعمل‌ها باعث استفادهٔ کارآمد از خط لولهٔ واحد پردازش مرکزی می‌شوند.

برخی از رایج‌ترین اسمبلرهای معماری ایکس۸۶ عبارتند از:
 مایکروسافت ماکرو اسمبلر .
 نت‌واید اسمبلر .
 گنو اسمبلر .
 توربو اسمبلر .

 تعداد گذرها 
دو نوع اسمبلر بر اساس تعداد گذرها از روی کد منبع برای تولید برنامهٔ قابل اجرا وجود دارد:
 اسمبلرهای یکبار-گذر فقط یک بار از روی کد عبور می‌کنند. هر نمادی که قبل از تعریف شدنش استفاده شده باشد به یک خطا  در پایان کد آبجکت (یا حداقل، بعد از محل تعریف در کد آبجکت) نیاز دارد تا به پیوندده اعلام کند که برگرد و حفره‌ای را که بر اثر استفاده از این نماد قبل از تعریف شدنش، جاگذاشته شده بود بازنویسی کن.
 اسمبلرهای چندبار-گذر جدولی از تمامی نمادها و مقادیر آنها در گذر اول ایجاد می‌کنند و سپس در گذرهای بعدی با استفاده از این جدول، نمادها را با مقادیر آنها جایگزین کرده و فایل اجرایی را تولید می‌کنند.

هدف اصلی در استفاده از اسمبلرهای یکبار-گذر، سرعت اسمبل کردن بود زیرا در گذر دوم به برگرداندن و بازخوانی نوار یا کارت پانچ، که در گذشته برای ذخیره‌سازی کدها استفاده می‌شدند، نیاز بود. این مشکل بعدها با وجود کامپیوترهای جدید برطرف شد. مزیت اسمبلرهای چندبار-گذر این است که در نبود خطاها در کد آبجکت، فرایند پیونددهی سریع‌تر انجام می‌شود.

 اسمبلرهای سطح-بالا 
اسمبلرهای پیچیده‌تر سطح-بالا انتزاع‌های زبانی زیر را فراهم می‌کنند:
 ساختارهای کنترل پیشرفته
 تعریف و فراخوانی رویه‌ها و توابع سطح-بالا
 انواع دادهٔ انتزاعی مانند رکوردها و ساختارها ، کلاس‌ها و مجموعه‌ها
 پردازش ماکرو پیشرفته
 قابلیت‌های برنامه‌نویسی شیءگرا مانند کلاس‌ها، انتزاع و وراثت

 زبان اسمبلی 
برنامه‌ای که به زبان اسمبلی نوشته می‌شود شامل مجموعه‌ای از دستورالعمل‌های پردازنده (یادیارها)، شبه-دستورها ، کامنت‌ها و داده‌ها است. دستورهای زبان اسمبلی معمولاً از یک آپ‌کد و سپس فهرستی از داده‌ها، آرگومان‌ها یا پارامترها تشکیل شده‌اند و توسط اسمبلر به دستورهای زبان ماشین ترجمه و به حافظه منتقل می‌شوند تا اجرا شوند.

برای مثال، دستور زیر به پردازندهٔ معماری ایکس۸۶/آی‌ای-۳۲ می‌گوید که یک مقدار ثابت ۸ بیتی را به یک ثبات منتقل کند. کد باینری این دستور 10110 است که پس از آن یک شناسهٔ ۳ بیتی می‌آید تا مشخص کند کدام ثبات باید استفاده شود. 000 شناسهٔ ثبات AL است، بنابراین کد ماشین زیر دادهٔ 01100001 را در ثبات AL بار می‌کند:

 10110000 01100001

این کد باینری را می‌توان با تبدیل به مبنای ۱۶ کمی خواناتر کرد:

 B0 61

در اینجا B0 به معنی انتقال مقدار بعدی به ثبات AL است و 61 نمایش مبنای ۱۶ مقدار باینری 01100001 است که باید منتقل شود و در مبنای ده برابر ۹۷ است. زبان اسمبلی اینتل یادیار MOV را (مخفف Move) برای دستورهای این چنینی فراهم کرده، به‌طوری‌که کد ماشین بالا در زبان اسمبلی به شکل زیر نوشته می‌شود که خواندن و به خاطر سپردن آن راحت‌تر است (آنچه بعد از نقطه-ویرگول (;) آمده توضیح  است):
MOV AL, 61h       ; Load AL with 97 decimal (61 hex)
برخی زبان‌های اسمبلی ممکن است از دستورهای مشابه MOV برای انتقال، کپی و بارگذاری داده‌ها، چه ثبات‌ها، چه مقادیر عددی و چه متغیرهای حافظه استفاده کنند و برخی دیگر از اسمبلرها ممکن از دستورهای متفاوتی استفاده کنند؛ مثلاً L برای انتقال حافظه به ثبات، ST برای انتقال از ثبات به حافظه، LR برای انتقال از ثبات به ثبات و MVI برای انتقال ثابت‌های عددی به ثبات و غیره.

آپ‌کد اینتل 10110000 (B0) یک مقدار ۸ بیتی را به ثبات AL کپی می‌کند، در حالیکه 10110001 (B1) آن را به CL منتقل می‌کند و 10110010 (B2) همین کار را با DL انجام می‌دهد. مثال‌های اسمبلی آن به صورت زیر است:
MOV AL, 1h        ; Load AL with immediate value 1
MOV CL, 2h        ; Load CL with immediate value 2
MOV DL, 3h        ; Load DL with immediate value 3
دستور MOV می‌تواند مانند مثال زیر به اشکال پیچیده‌تری نیز استفاده شود:
MOV EAX, [EBX]   ; Move the 4 bytes in memory at the address contained in EBX into EAX
MOV [ESI+EAX], CL ; Move the contents of CL into the byte at address ESI+EAX
در هر حالت، دستور MOV مستقیماً توسط اسمبلر به یک آپ‌کد در بازهٔ 88-8E یا A0-A3 یا B0-B8 یا C6 یا C7 ترجمه می‌شود و برنامه‌نویس مجبور به دانستن یا حفظ کردن آن‌ها نیست.

تبدیل زبان اسمبلی به زبان ماشین وظیفهٔ اسمبلر است و عکس این عمل تا حدی توسط دی‌اسمبلر امکان‌پذیر است. برخلاف زبان‌های برنامه‌نویسی سطح بالا، ارتباط یک به یکی بین دستورهای زبان اسمبلی و دستورالعمل‌های زبان ماشین وجود دارد. با این حال، در برخی موارد، یک اسمبلر ممکن است شبه‌دستورهایی  را به کار بگیرد (اساساً ماکروها) که به چند دستورالعمل زبان ماشین تبدیل می‌شود تا پاسخگوی نیازهای رایج باشد.

هر معماری کامپیوتر زبان ماشین مختص به خود را داراست. کامپیوترها در تعداد و نوع دستورهای قابل استفاده، تعداد و اندازهٔ ثبات‌ها و نحوهٔ انبارش داده‌ها با یکدیگر تفاوت دارند. با اینکه کامپیوترهای همه منظوره اساساً قادر به انجام کارکردهای مشابه هستند ولی این کار را با روش‌های گوناگونی انجام می‌دهند؛ بنابراین زبان اسمبلی مربوط به آن‌ها نیز این تفاوت‌ها را منعکس می‌کند.

مجموعه‌های متعددی از یادیارها یا دستورهای زبان اسمبلی ممکن است برای یک مجموعه دستورالعمل واحد وجود داشته باشد، که به‌طور معمول در برنامه‌های اسمبلی مختلفی نمونه‌سازی می‌شوند. در این موارد، رایج‌ترین آن‌ها معمولاً نمونه‌ای است که توسط کارخانهٔ سازنده عرضه می‌شود یا در مستندات آن‌ها استفاده شده‌است.

 کاربرد زبان اسمبلی 
 چشم‌انداز تاریخی 
در زمانی که کامپیوتر با قابلیت ذخیره کردن برنامه معرفی شد، زبان‌های اسمبلی در دسترس نبودند. کثلین بوث مسئول اختراع زبان اسمبلی می‌باشد؛ که بر پایهٔ کار نظری اش که در سال ۱۹۷۴ آغاز کرد، می‌باشد. همزمان که با همفکری اندرو بوث (که در آینده همسر او شد) و با ریاضی‌دانی به نام جان فون نویمان و فیزیکدانی به نام هرمن گلداستاین در مؤسسه مطالعه‌های پیشرفته، بر روی ARC2 در دانشگاه لندن، بیرکبک کار می‌کرد.
در اواخر ۱۹۴۸، محاسبه کننده ی خودکار مخزن تأخیر الکترونیکی (EDSAC) یک اسمبلر (به نام دستورهای اولیه) داشت که با برنامهٔ خودراه انداز آن دستگاه یکپارچه شده بود. از حافظه ای تک حرفی استفاده می‌کرد که به وسیلهٔ دیوید ویلر توسعه یافت. کسی که به عنوان سازندهٔ اولین اسمبلر، مسئول جامعهٔ کامپیوتر IEEE می‌باشد. گزارش‌های دربارهٔ EDSAC، اسمبلی را برای فرایند ترکیب زمینه‌ها برای رسیدن به یک کلمهٔ راهنما معرفی کردند. SOAP (برنامهٔ اسمبلی بهینهٔ نمادین) یک زبان اسمبلی برای کامپیوتر IBM 650 بود که به وسیلهٔ استن پلی در ۱۹۵۵ نوشته شد.
زبان اسمبلی تعداد زیادی از نیازهای مستعد خطا، خسته کننده و وقت گیر برنامه‌نویسی نسل اول با اولین کامپیوترها را ازبین برد؛ و برنامه نویسان را از موارد خسته کننده ای از جمله به خاطر سپردن کدهای عددی و محاسبه کردن آدرس‌ها آزاد کرد. آن‌ها یک بار به‌طور گسترده برای همهٔ انواع برنامه‌نویسی استفاده شدند. با این حال در دههٔ ۱۹۸۰ (در دههٔ ۱۹۹۰ برای ریزرایانه‌ها) در جستجو برای بهره‌وری برنامه‌نویسی که اثبات شده‌است، استفاده از آنها به مقدار زیادی با زبان‌های سطح بالا جایگزین شد. امروزه زبان اسمبلی هنوز برای دست کاری دستی سخت‌افزار، دسترسی به دستورالعمل‌های مخصوص پردازنده، یا برای آدرس دهی موضوع‌های ساختاری بحرانی استفاده می‌شود. نمونه‌های استفاده عبارت اند از گرداننده‌های دستگاه، سیستم‌های نهفتهٔ سطح پایین، و سیستم‌های بی درنگ.
از دید تاریخی، برنامه‌های متعددی وجود دارند که کاملاً به زبان اسمبلی نوشته شده‌اند. باروز ام‌سی‌پی(۱۹۶۱)(Burroughs MCP) اولین کامپیوتری بود که سیستم عملیاتی به‌طور کامل به زبان اسمبلی توسعه نیافته بود؛ بلکه در زبان مشکل محور سیستم‌های اجرایی (ESPOL) ـ که یک گویش از الگول (زبان الگوریتمی) می‌باشد ـ نوشته شده بود. همچنین بسیاری از کاربردهای تجاری به زبان اسمبلی نوشته شدند. به انضمام مقدار زیادی نرم‌افزارهای رایانه‌های بزرگ آی‌بی‌ام که نوشته شده به وسیلهٔ شرکت‌های بزرگ بود. کوبول، فورترن و بعضی از PL/Iها سرانجام جایگزین مقدار زیادی از این کار شدند. اگرچه تعدادی از سازمان‌های بزرگ در دههٔ ۱۹۹۰، کاربرد زیرساخت‌هایی با زبان‌های اسمبلی را به خوبی حفظ کردند.
بیشتر ریزرایانه‌های اولیه بر زبان اسمبلی از نوع کدگذاری دستی تکیه کردند. به انضمام بیشتر سیستم‌های عملیاتی و برنامه‌های بزرگ. این بخاطر این بود که این سیستم‌ها محدودیت‌های شدید منابع، ساختارهای حافظه و نمایش ویژهٔ تحمیلی و سرویس‌های سیستمی مشکل دار و محدود شده آماده شده داشتند. احتمالاً فقدان کامپایلرهای با زبان سطح بالای درجه یک مناسب برای استفاده ریزرایانه چیز مهمتری بود. یک عامل روانشناسانه نیز احتمالاً نقش بازی می‌کرد: اولین نسل برنامه نویسان ریزرایانه‌ها که باقی ماندند افراد دیوانهٔ بازی با نگرشی خاص بودند.
در مفهومی تجاری تر، حداقل اندازه، حداقل میزان پردازش مورد نیاز، سرعت بهتر و قابل اعتماد بودن از بزرگ‌ترین دلایل برای استفاده از زبان اسمبلی بودند.
سیستم عملیاتی IBM PC DOS، کامپایلر توربو پاسکال و برنامه‌های اولیه مانند برنامهٔ صفحه گسترده ی لوتوس ۱-۲-۳، مثال‌های نمونهٔ برنامه‌های بزرگ با زبان اسمبلی در این زمان می‌باشند. زبان اسمبلی در گذشته بهترین نمایش را در سگا ساترن - برای توسعه و برنامه‌نویسی بازی‌های این کنسول که به‌طور آشکار چالش‌برانگیز بود - داشت. بازی ان بی ای جم که یک بازی مخصوص دستگاه‌های بازی ویدئویی بود، مثال دیگری می‌باشد.
زبان اسمبلی برای یک مدت طولانی زبان اصلی توسعه برای بسیاری از بازی‌های کامپیوتری در دهه‌های ۱۹۸۰ و ۱۹۹۰ بود (از جمله ام‌اس‌ایکس، سینکلر زد ایکس اسپکتروم، کمودور ۶۴، کومودور آمیگا و آتاری اس‌تی). این در بخش بزرگی بود زیرا گویش پایهٔ تفسیری در این سیستم‌ها با عث سرعت اجرایی ناکافی می‌شد همچنان که باعث قابلیت‌های ناکافی برای بدست آوردن همهٔ مزیت‌های سخت‌افزار موجود در این سیستم‌ها می‌شد. بعضی از سیستم‌ها حتی یک محیط یکپارچه توسعه نرم‌افزار (IDE) دارند که دارای قابلیت فوق پیشرفته اشکال زدایی و قابلیت‌های ماکروها هستند. بعضی از کامپایلرهای در دسترس برای ریدیوشک تی آر اس-۸۰ و جانشینانش، قابلیت ترکیب برخط منبع اسمبلی با جمله‌های سطح بالای برنامه را داشتند. پس از گردآوری، یک اسمبلر درونی کدهای برخط ماشین را تولید کرد.

 کاربرد کنونی 
همواره بحث‌هایی دربارهٔ کاربردی بودن و نمایش زبان اسمبلی در مقابل زبان‌های سطح بالا بوده‌است.
اگرچه در جایگاه‌های مخصوصی که اهمیت دارند، زبان اسمبلی استفاده می‌شود (بالا را مشاهده کنید)، اما ابزارهای دیگری برای بهینه‌سازی وجود دارند.
در ژوئیه ۲۰۱۷ شاخص تیوبی رتبهٔ محبوبیت زبان برنامه‌نویسی، زبان اسمبلی در رتبهٔ ۱۱ بالاتر از مثلاً ویژوال بیسیک بود. اسمبلر می‌تواند برای بهینه‌سازی سرعت یا بهینه‌سازی اندازه استفاده شود. در حالت بهینه‌سازی سرعت، کامپایلرهای بهینه‌ساز مدرن مدعی می‌شوند که زبان‌های سطح بالا را به کدهایی تبدیل می‌کنند که می‌توانند به سرعت اسمبل با دست نوشته شده اجرا شوند، گرچه مثال‌های خلاف هم می‌توانند پیدا شوند. پیچیدگی پردازنده‌های مدرن و سیستم‌های فرعی حافظه‌ها، بهینه‌سازی مؤثر را به‌طور افزاینده ای برای کامپایلر و همچنین برای برنامه نویسان اسمبلی سخت می‌کنند. علاوه بر این افزایش نمایش پردازنده‌ها به این معنی است که بیشتر سی پی یوها بیشتر مواقع بی فایده مانده‌اند، با تأخیرهایی که به خاطر تنگه‌های قابل پیش‌بینی مانند از دست دادن حافظهٔ پنهان، عملیات‌ها و صفحه بندی I/O رخ داده‌است. همین، سرعت اجرای کد خام را برای بسیاری از برنامه نویسان بی‌اهمیت کرده‌است.
در اینجا تعدادی موقعیت وجود دارد که احتمالاً توسعه دهندگان انتخاب بکنند تا از زبان اسمبلی استفاده بکنند.
 نوشتن کد برای سیستم‌هایی با پردازنده‌های قدیمی تر که گزینه‌های محدودی برای زبان‌های سطح بالا دارند. از جمله آتاری ۲۶۰۰، کومودور ۶۴ و ماشین حساب‌های با قابلیت رسم نمودار.
 کدی که باید تعامل مستقیم با سخت‌افزار داشته باشد برای مثال در گرداننده‌های دستگاه و کنترل‌کننده‌های قطع شدن‌ها.
 در یک پردازندهٔ توکار یا DSP، قطعی مکرر نیازمند کوتاه‌ترین تعداد حلقه‌ها در هر قطعی می‌باشد، مانند یک قطعی که ۱۰۰۰ یا ۱۰۰۰۰ بار در ثانیه اتفاق می‌افتد.
 برنامه‌هایی که نیازمند استفاده از پردازنده ـ دستور العمل‌های مخصوصی که در یک کامپایلر اجرا نشدند ـ می‌باشند. یک مثال رایج، دستورالعمل چرخش بیتی در هستهٔ بسیاری از الگوریتم‌های رمز گذاری می‌باشد، همان‌طور که در توازن یک بایت جستجو می‌شود یا رقم نقلی ۴-بیتی در یک جمع.
 یک چیز قابل اجرا با سایز متراکم و مستقل مورد نیاز است که باید بدون منبع گرفتن از مؤلفه‌های زمان اجرا یا کتابخانه‌های مرتبط با یک زبان سطح بالا اجرا کند. مثال‌ها شامل سیستم عامل تلفن‌ها، سیستم سوخت و احتراق ماشین‌ها، سیستم‌های کنترل دستگاه‌های تهویهٔ مطبوع، سیستم‌های امنیتی و سنسورها.
 برنامه‌های با حلقه‌های درونی حساس به نمایش. در حالی که زبان اسمبلی فرصت‌های بهینه‌سازی را فراهم می‌کند که بدست آوردن آنها در یک زبان سطح بالا پیچیده هستند. برای مثال جبر خطی با BLAS یا تبدیل کسینوسی گسسته (مثلا ورژن اسمبلی SIMD از x264).
 برنامه‌هایی که تابع‌های برداری شده را برای برنامه‌ها در زبان‌های سطح بالاتر از جمله C می‌سازند. در زبان‌های سطح بالاتر این فرایند گاهی توسط تابع‌های ذاتی کامپایلر پشتیبانی می‌شوند که مستقیماً به حافظه‌های SIMD مرتبط می‌کند، ولی با این وجود در یک گفت و گوی یک به یک اسمبلی که مخصوص پردازندهٔ برداری داده شده‌است نتیجه می‌دهد.
 برنامه‌های بی درنگ از جمله شبیه‌سازی‌ها، سیستم‌های جهت‌یاب پروازی و وسایل پزشکی. برای مثال در یک سیستم هدایت پرواز برقی، مسافت سنج باید ترجمه بشود و براساس قیود زمانی معین عمل کند. این سیستم‌ها باید منابع تأخیرهای غیرقابل پیش‌بینی را حذف کنند، که ممکن است که با بعضی از زبان‌های ترجمه شده، بازیافت خودکار حافظه، صفحه بندی عملیات‌ها یا [[قبضه کردن چند وظیفه‌ای] ایجاد شوند. با این حال بعضی از زبان‌های سطح بالا مؤلفه‌های زمان اجرا و رابط‌های عملیاتی سیستم را ترکیب می‌کنند که می‌توانند چنین تأخیرهایی را معرفی کنند. انتخاب کردن زبان اسمبلی یا زبان‌های سطح پایین‌تر برای چنین سیستم‌هایی به برنامه نویسان دید و کنترل بهتر بر تفاصیل پردازش می‌دهد.
 الگوریتم‌های رمز نگاری که همیشه باید دقیقاً زمانی مشابه برای اجرا داشته باشند تا از حمله‌های زمانبندی جلوگیری کنند.
 اصلاح کردن و گسترش کد ارثی نوشته شده برای کامپیوترهای بزرگ آی بی ام.
 در محیط‌هایی که کنترل کامل بر محیط مورد نیاز است، در موقعیت‌های فوق امنیتی که همه چیز به شدت بررسی می‌شود.
 ویروس‌های کامپیوتر، بارگذارهای بوت (راه اندازی)، گرداننده‌های معین دستگاه یا دیگر آیتم‌های بسیار نزدیک به سخت‌افزار یا سیستم عملیاتی سطح پایین.
 شبیه‌سازهای مجموعه ی دستور العمل‌ها برای نظارت، ردیابی و اشکال زدایی که میزان اضافی پردازش مورد نیاز در حد حداقل نگه داشته می‌شود.
 موقعیت‌هایی که هیچ زبان سطح بالایی وجود ندارد، بر روی یک پردازندهٔ جدید یا ویژه که هیچ کامپایلر دوگانه ای فعال نیست.
 مهندسی معکوس و اصلاح کردن فایل‌های برنامه؛ از جمله:
 وجود داشتن دودویی‌هایی که شاید در اصل در یک زبان سطح بالا نوشته شده‌اند یا نوشته نشده‌اند، برای مثال هنگام تلاش برای ساخت دوبارهٔ برنامه‌هایی که کد منبع آنها در دسترس نمی‌باشد یا گم شده‌است یا کرک کردن رونوشت حفاظت نرم‌افزار اصلی.
 بازی‌های ویدئویی (همچنین اصطلاح هک کردن رم) که از روش‌های متفاوت امکان‌پذیر است. بیشترین روشی که به‌طور گسترده به کار گرفته می‌شود تغییر دادن کد برنامه در سطح زبان اسمبلی است.
زبان اسمبلی هنوز در بسیاری از برنامه‌های مهندسی برق و علوم کامپیوتر آموزش داده می‌شود. اگرچه تعداد کمی از برنامه نویسان امروزه معمولاً با زبان اسمبلی به عنوان ابزار کار می‌کنند، اما مفاهیم اصولی بااهمیت باقی می‌مانند. مفاهیم ابتدایی از جمله اعمال ریاضی در اعداد دو دویی]]، اختصاص حافظه، پردازش پشته، کدگذاری مجموعهٔ کاراکترها، قطع شدن پردازش و طراحی کامپایلر که مطالعه در تفاصیل آن‌ها بدون فهمیدن اینکه یک کامپیوتر چگونه در سطح سخت‌افزار عمل می‌کند، سخت خواهد بود. از زمانی که رفتار کامپیوتر، به شکل ابتدایی به وسیلهٔ مجموعهٔ دستور العمل‌هایش تعریف می‌شود، راه منطقی برای یادگرفتن چینن مفهوم‌هایی، مطالعهٔ که یک زبان اسمبلی است. بیشتر کامپیوترهای مدرن مجموعهٔ دستور العمل‌های مشابه دارند؛ بنابراین مطالعهٔ تنها یک زبان اسمبلی کافی است برای یادگیری: I) مفاهیم پایه؛ II) تشخیص موقعیت‌هایی که استفاده از زبان اسمبلی می‌تواند مناسب باشد؛ III) دیدن اینکه چه مقدار کد قابل اجرای کارآمد از یک زبان سطح بالا می‌تواند ساخته شود.

 برنامه‌های نمونه 
 زبان اسمبلی به‌طور نمونه در کد راه اندازی یک سیستم استفاده می‌شود، کد سطح پایینی که مقدار اولیه می‌دهد و سخت‌افزار سیستم را تست می‌کند پیش از راه اندازی سیستم عملیاتی و معمولاً در رم ذخیره می‌شود. (بایوس در سیستم‌های سازگار با کامپیوترهای شخصی آی بی ام و CP/M یک نمونه است)
 بعضی از کامپایلرها زبان‌های سطح بالا را قبل از کامپایل کامل به اسمبلی ترجمه می‌کنند، در حالی که به کد اسمبلی اجازه می‌دهد تا به هدف اشکال زدایی و بهینه‌سازی نشان داده شود.
 بعضی از کامپایلرها برای زبان‌های نسبتاً سطح پایین، از جمله پاسکال یا سی، به برنامه‌نویس اجازه می‌دهند تا زبان اسمبلی را مستقیماً درون کد منبع جا دهد (که اسمبلر درون‌برنامه‌ای نامیده می‌شود). برنامه‌هایی که از این قابلیت‌ها استفاده می‌کنند می‌توانند انتزاع‌هایی بسازند که از زبان‌های اسمبلی متفاوت در هر پلتفرم سخت‌افزاری استفاده می‌کنند. کد قابل جابجایی سیستم می‌توانند از این پردازنده ها-مؤلفه‌های مخصوص در یک سطح مشترک یکنواخت-استفاده کنند.
 زبان اسمبلی در مهندسی معکوس سودمند می‌باشد. بسیاری از برنامه‌ها تنها به فرم کد ماشین توزیع شده‌اند که برای ترجمه به زبان اسمبلی به وسیلهٔ یک مجزا کننده (دیس‌اسمبلر) آسان می‌باشد، ولی برای ترجمه به زبان سطح بالاتر از طریق مترجم‌وارون(دی‌کامپایلر) سخت‌تر می‌باشد. ابزارهایی همچون مجزاکننده تعاملی استفاده از دیس اسمبلی را برای چنین منظوری گسترده می‌کند. این تکنیک به وسیلهٔ هکرها برای کرک کردن نرم‌افزارهای تجاری استفاده می‌شود و به وسیلهٔ رقبا برای تولید نرم‌افزار با نتایج مشابه شرکت‌های رقیب استفاده می‌شود.
 زبان اسمبلی برای ارتقای سرعت اجرا استفاده می‌شود، مخصوصاً در کامپیوترهای اولیه با توان پردازش و رم محدود.
 اسمبلرها می‌توانند استفاده شوند تا دسته ای از دیتاها را از کدهای منبع قالب بندی شده و یادداشت شده و بدون نیاز به پردازش مورد نیاز زبان‌های سطح بالا، تولید بکنند تا به وسیلهٔ دیگر کدها استفاده بشوند.

 جستارهای وابسته 
 پیوندده
 آپ‌کد
 زبان ماشین
 مجموعه دستورالعمل
 رداسم

 منابع 

 

رده:اسمبلرها
رده:پیاده‌سازی زبان برنامه‌نویسی
رده:زبان‌های اسمبلی
رده:زبان‌های برنامه‌نویسی سطح پایین
رده:سامانه‌های توکار
رده:معرفی‌شده‌های مرتبط با رایانه در ۱۹۴۹ (میلادی)
رده:نرم‌افزارهای ۱۹۴۹ (میلادی)