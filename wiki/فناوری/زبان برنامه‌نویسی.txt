بندانگشتی|402px|کد منبع برای یک برنامه رایانه ای ساده که به زبان برنامه‌نویسی C نوشته شده‌است. هنگام کامپایل و اجرا، خروجی "سلام، جهان!" می‌دهد.|جایگزین=

زبان‌های برنامه‌نویسی ساختارهای زبانی دستور مداری در رایانه‌ها هستند که به‌وسیلهٔ آن‌ها می‌توان یک الگوریتم را به‌وسیلهٔ ساختارهای دستوری متفاوت برای اجرای رایانه توصیف کرد و با این روش امکان نوشتن برنامه جهت تولید نرم‌افزارهای جدید به وجود می‌آید. معمولاً هر زبان برنامه‌نویسی دارای یک محیط نرم‌افزاری برای وارد کردن متن برنامه، اجرا، همگردانی و رفع اشکال آن هستند.

یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصا رایانه) قابل انجام است، طراحی شده‌است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای ارتباط انسانند.
بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری(syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی می‌باشند. (مانند Perl)
اولین زبان برنامه‌نویسی به قبل از اختراع رایانه بازمی‌گردد، و برای هدایت رفتار ماشین‌هایی مانند دستگاه‌های نساجی اتوماتیک و نوازنده‌های پیانو به کار می‌رفت.

هزاران زبان برنامه‌نویسی خلق شده‌است، که بیشتر آن‌ها در زمینهٔ رایانه هستند، زمینه‌ای که هر ساله بسیاری زبان دیگر در آن ایجاد می‌شود.

 تعاریف 
ویژگی‌هایی که غالباً برای تشکیل یک زبان برنامه‌نویسی مهم شمرده می‌شوند:
 کاربرد: یک زبان برنامه‌نویسی، زبانی است که برای نوشتن برنامه‌های رایانه‌ای به کار می‌رود که رایانه‌ای را برای انجام محاسبات یا اجرای الگوریتم یا احتمالاً کنترل دستگاه‌های خارجی مثل چاپگر، ربات و… درگیر می‌کنند.
 هدف: زبان‌های برنامه‌نویسی با زبان‌های طبیعی تفاوت دارند و آن اینکه زبان‌های طبیعی فقط برای فعل و انفعالات بین مردم به کار می‌روند، در حالیکه زبان‌های برنامه‌نویسی همچنین به انسان‌ها اجازه می‌دهد که از طریق دستورهای با ماشین‌ها ارتباط برقرار کنند. برخی زبان‌های برنامه‌نویسی به وسیلهٔ یک دستگاه استفاده می‌شوند تا دستگاه دیگری را کنترل کند. برای مثال برنامه‌های پست اسکریپت(post script) غالباً توسط برنامه دیگری برای کنترل یک چاپگر یا نمایشگر ایجاد می‌شوند.
 ساختارها: زبان‌های برنامه‌نویسی ممکن است ساختارهایی برای تعریف و تغییر داده ساختارها یا کنترل جریان اجرا داشته باشند.
 توان بیانگر: نظریه محاسبات، زبان‌ها را به وسیلهٔ محاسباتی که توان بیان آن‌ها را دارند طبقه‌بندی می‌کند. تمام زبان‌های «کامل تورینگ» می‌توانند مجموعه یکسانی از الگوریتم‌ها را پیاده‌سازی کنند.ANSI/ISO SQL و Charity مثال‌هایی هستند از زبان‌هایی که کامل تورینگ نیستند، ولی غالباً زبان برنامه‌نویسی نامیده می‌شوند.
برخی مؤلفین اصطلاح «زبان برنامه‌نویسی» را محدود به آن‌هایی می‌کنند که می‌توانند تمام الگوریتم‌های ممکن را پیاده‌سازی کنند، گاهی اوقات اصطلاح «زبان رایانه» برای زبان‌های برنامه‌نویسی محدودتر به کار می‌رود.
زبان‌های غیر محاسباتی، مانند زبان‌های مارک آپ(markup) HTML یا گرامرهای قراردادی مثل BNF، معمولاً زبان برنامه‌نویسی محسوب نمی‌شوند. یک زبان برنامه‌نویسی (که می‌تواند کامل تورینگ نباشد) ممکن است در این زبان‌های غیر محاسباتی (میزبان) تعبیه شوند.

 تاریخچه 
 پیشرفت‌های اولیه 
اولین زبان برنامه‌نویسی به قبل از رایانه‌های مدرن بازمی‌گردد. قرن ۱۹ دستگاه‌های نساجی و متون نوازنده پیانو قابل برنامه‌نویسی داشت که امروزه به عنوان مثال‌هایی از زبان‌های برنامه‌نویسی با حوزه مشخص شناخته می‌شوند. با شروع قرن بیستم، پانچ کارت‌ها داده را کدگذاری کردند و پردازش مکانیکی را هدایت کردند. در دهه ۱۹۳۰ و ۱۹۴۰، صورت گرایی حساب لاندای آلونزو چرچ و ماشین تورینگ آلن تورینگ مفاهیم ریاضی بیان الگوریتم‌ها را فراهم کردند؛ حساب لاندا همچنان در طراحی زبان مؤثر است.

در دهه ۴۰، اولین رایانه‌های دیجیتال که توسط برق تغذیه می‌شدند ایجاد شدند. اولین زبان برنامه‌نویسی سطح بالا طراحی شده برای کامپیوتر پلان کلکول بود، که بین سال‌های ۱۹۴۵ و ۱۹۴۳ توسط کنراد زوس برای ز۳ آلمان طراحی شد.

کامپیوترهای اوایل ۱۹۵۰، به‌طور خاص ÜNIVAC ۱ و IBM ۷۰۱ از برنامه‌های زبان ماشین استفاده می‌کردند. برنامه‌نویسی زبان ماشین نسل اول توسط نسل دومی که زبان اسمبلی نامیده می‌شوند جایگزین شد. در سال‌های بعد دهه ۵۰، زبان برنامه‌نویسی اسمبلی، که برای استفاده از دستورهای ماکرو تکامل یافته بود، توسط سه زبان برنامه‌نویسی سطح بالا دیگر: FORTRAN,LISP , COBOL مورد استفاده قرار گرفت. نسخه‌های به روز شده این برنامه‌ها همچنان مورد استفاده قرار می‌گیرند، و هر کدام قویا توسعه زبان‌های بعد را تحت تأثیر قرار دادند. در پایان دهه ۵۰ زبان algol ۶۰ معرفی شد، و بسیاری از زبان‌های برنامه‌نویسی بعد، با ملاحظه بسیار، از نسل algol هستند. قالب و استفاده از زبان‌های برنامه‌نویسی به شدت متأثر از محدودیت‌های رابط بودند.

 پالایش 
دوره دهه ۶۰ تا اواخر دهه ۷۰ گسترش مثال‌های عمده زبان پرکاربرد امروز را به همراه داشت. با این حال بسیاری از جنبه‌های آن بهینه‌سازی ایده‌های اولیه نسل سوم زبان برنامه‌نویسی بود:
 APL برنامه‌نویسی آرایه‌ای را معرفی کرد و برنامه‌نویسی کاربردی را تحت تأثیر قرار داد.
 PL/i(NPL) دراوایل دهه ۶۰ طراحی شده بود تا ایده‌های خوب فورترن و کوبول را بهم پیوند دهد.
 در دهه ۶۰، Simula اولین زبانی بود که برنامه‌نویسی شیء گرا را پشتیبانی می‌کرد، به دنبال آن در اواسط دهه۷۰، Smalltalk به عنوان اولین زبان کاملاً شیء گرا معرفی شد.
 C بین سال‌های ۱۹۶۹ تا ۱۹۷۳ به عنوان زبان برنامه‌نویسی سیستمی طراحی شد و همچنان محبوب است.
 PASCAL و BASIC (که در آینده به زبان ویژوال بیسیک معروف شد) در ابتدا یک زبان آموزشی بودند ولی بعدها با ارائه کامپایلرهای مختلف آن کاربردی شدند.
 LISP از جمله زبان‌هایی بود که براساس پردازش لیست‌ها کار می‌کرد و برای الگوریتم‌های هوش مصنوعی مناسب بود.
 Prolog، طراحی شده در ۱۹۷۲، اولین زبان برنامه‌نویسی منطقی بود؛ که برای الگوریتم‌های هوش مصنوعی مناسب بود.
 در ۱۹۷۸ ML سیستم نوع چند ریخت روی لیسپ ایجاد کرد، و در زبان‌های برنامه‌نویسی کاربردی ایستا نوع‌گذاری شده پیشگام شد.
هر یک از این زبان‌ها یک خانوادهٔ بزرگ از وارثین خود را به جای گذاشتند، و مدرن‌ترین زبان‌ها، از تبار حداقل یکی از زبان‌های بالا به‌شمار می‌آیند.

دهه‌های ۶۰ و ۷۰، مناقشات بسیاری روی برنامه‌نویسی ساخت یافته به خود دیدند، و اینکه آیا زبان‌های برنامه‌نویسی باید طوری طراحی شوند که آن‌ها را پشتیبانی کنند.

«ادسگر دیکسترا» در نامه‌ای معروف در ۱۹۶۸ که در ارتباطات ACM منتشر شد، استدلال کرد که دستورgoto باید از تمام زبان‌های سطح بالا حذف شود.

در دهه‌های ۶۰ و ۷۰ توسعهٔ تکنیک‌هایی صورت گرفت که اثر یک برنامه را کاهش می‌داد و در عین حال بهره‌وری برنامه‌نویس و کاربر را بهبود بخشید. دسته کارت برای ۴GL اولیه بسیار کوچکتر از برنامهٔ هم سطح بود که با ۳GL deck نوشته شده بود.

 یکپارچگی و رشد 
دهه ۸۰ سال‌های یکپارچگی نسبی بود. C++ برنامه‌نویسی شیء گرا و برنامه‌نویسی سیستمی را ترکیب کرده بود. ایالات متحده ایدا (زبان برنامه‌نویسی سیستمی که بیشتر برای استفاده توسط پیمان کاران دفاعی بود) را استانداردسازی کرد. در ژاپن و جاهای دیگر، هزینه‌های گزافی صرف تحقیق در مورد زبان نسل پنجم می‌شد که دارای ساختارهای برنامه‌نویسی منطقی بود. انجمن زبان کاربردی به سمت استانداردسازی ML و Lisp حرکت کرد. به جای ایجاد مثال‌های جدید، تمام این تلاش‌ها ایده‌هایی که در دهه‌های قبل خلق شده بودند را بهتر کرد.

یک گرایش مهم در طراحی زبان در دهه ۸۰ تمرکز بیشتر روی برنامه‌نویسی برای سیستم‌های بزرگ از طریق مدول‌ها، یا واحدهای کدهای سازمانی بزرگ مقیاس بود. مدول-۲، ایدا؛ و ML همگی سیستم‌های مدولی برجسته‌ای را در دهه ۸۰ توسعه دادند. با وجود اینکه زبان‌های دیگر، مثل PL/i، پشتیبانی بسیار خوبی برای برنامه‌نویسی مدولی داشتند. سیستم‌های مدولی غالباً با ساختارهای برنامه‌نویسی عام همراه شده‌اند.

رشد سریع اینترنت در میانه دهه ۹۰ فرصت‌های ایجاد زبان‌های جدید را فراهم کرد. Perl، در اصل یک ابزار نوشتن یونیکس بود که اولین بار در سال ۱۹۸۷ منتشر شد، در وبگاه‌های دینامیک متداول شد. جاوا برای برنامه‌نویسی جنب سروری مورد استفاده قرار گرفت. این توسعه‌ها اساساً نو نبودند، بلکه بیشتر بهینه‌سازی شده زبان و مثال‌های موجود بودند، و بیشتر بر اساس خانواده زبان برنامه‌نویسی C بودند.
پیشرفت زبان برنامه‌نویسی همچنان ادامه پیدا می‌کند، هم در تحقیقات و هم در صنعت. جهت‌های فعلی شامل امنیت و وارسی قابلیت اعتماد است، گونه‌های جدید مدولی(mixin، نماینده‌ها، جنبه‌ها) و تجمع پایگاه داده.

۴GLها نمونه‌ای از زبان‌هایی هستند که محدوده استفاده آن‌ها مشخص است، مثل SQL. که به جای اینکه داده‌های اسکالر را برگردانند، مجموعه‌هایی را تغییر داده و برمی‌گردانند که برای اکثر زبان‌ها متعارفند. Perl برای مثال، با «مدرک اینجا» خود می‌تواند چندین برنامه ۴GL را نگه دارد، مانند چند برنامه جاوا اسکریپت، در قسمتی از کد پرل خود و برای پشتیبانی از چندین زبان برنامه‌نویسی با تناسب متغیر در «مدرک اینجا» استفاده کند.
 نسل یکم، زبان ماشین است همان زبان صفر و یک.
 نسل دوم، زبان‌هایی مانند اسمبلی و مشتق آن هستند که برای انسان قابل فهم‌تر هستند.
 نسل سوم، زبان‌هایی مانند کوبول و پی ال وان و… هستند که دارای دستورهای قابل فهم‌تری برای انسان هستند و به کامپایلرها نیاز دارند.
 نسل چهارم، زبان‌هایی مانند اوراکل و فاکس پرو و اس کیو ال‌ها هستند و این نسل از زبان‌ها چیزی نزدیک به محاوره‌های انسانی است.
 نسل پنجم، زبان‌هایی مانند prolog,ops5، ویژوال بیسیک هستند که تمرکز آن‌ها بر حل مسئله و استفاده از الگوریتم‌های نوشته شده توسط برنامه‌نویس است.

 تقسیم‌بندی 
زبان‌های برنامه‌نویسی را می‌توان از چهار دیدگاه متفاوت مورد بررسی قرار داده و تقسیم‌بندی کرد:

الف) روش‌های برنامه‌نویسی
 زیر روالی
 ساخت یافته
 مدولار
 شیء گرا

ب) نزدیکی به زبان ماشین
 سطح پایین
 سطح میانی
 سطح بالا

ج) نوع ترجمه
 مفسری
 کامپایلری

د) رابط برنامه‌نویسی
 مبتنی بر متن
 مبتنی بر گرافیک (ویژوال)

نکته: امروزه با وجود ماشین‌های مجازی، تقسیم‌بندی زبان‌های برنامه‌نویسی بر اساس نوع ترجمه، اشتباه می‌باشد. ماشین مجازی HipHop (مورد استفاده شرکت فیسبوک برای کاهش مرحله تفسیر در PHP) و همچنین کامپایل زبان برنامه‌نویسی پایتون به کلاس‌های جاوا نمونه‌هایی از چندگانگی نوع ترجمه در زبان‌های برنامه‌نویسی می‌باشد.

 عنصرها 
تمام زبان‌های برنامه‌نویسی تعدادی بلوک‌های ابتدایی برای توضیح داده و پردازش یا تبدیل آن‌ها (مانند جمع کردن دو عدد با انتخاب یک عضو از یک مجموعه) دارند. این «عناصر ابتدایی» به وسیلهٔ قوانین معناشناسی و دستوری تعریف می‌شوند که ساختار و معنای مربوط را توضیح می‌دهند.

 دستور(syntax) 
فرم سطحی یک زبان برنامه‌نویسی دستور آن نامیده می‌شود. بیشتر زبان‌های برنامه‌نویسی کاملاً متنی‌اند؛ و از دنبالهٔ متون شامل واژگان، اعداد و نشان‌گذاری‌های بسیار شبیه زبان نوشتاری طبیعی استفاده می‌کنند. از طرف دیگر، برنامه‌هایی نیز وجود دارند که بیشتر گرافیکی‌اند، و از روابط بصری بین سمبل‌ها برای مشخص کردن برنامه استفاده می‌کنند.
دستور یک زبان، ترکیبات ممکن سمبل‌ها برای ایجاد یک برنامهٔ درست را از نظر دستوری مشخص می‌کند. معنایی که به یک ترکیب سمبل‌ها داده می‌شود با معناشناسی اداره می‌شود (قراردادی یا نوشته شده در پیاده‌سازی منبع). از آنجا که بیشتر زبان‌ها متنی هستند، این مقاله دستور متنی را مورد بحث قرار می‌دهد.

دستور زبان برنامه‌نویسی معمولاً به وسیلهٔ ترکیب عبارات معین (برای ساختار لغوی) و فرم توضیح اعمال (برای ساختار گرامری) تعریف می‌شوند.

متن زیر یک گرامر ساده، به زبان Lisp است:expression   : :=  atom  |  list
atom           : :=  number  |  symbol
number       : :=  [+-]?[' 0 ' - ' 9 ']+
symbol        : :=  [' A ' - ' Z ' ' a ' - ' z ']. *
list              : :=  ' ( '  expression*  ' ) 'این گرامر موارد ذیل را مشخص می‌کند:
 یک عبارت یا atom است یا یک لیست
 یک atom یا یک عدد است یا یک سمبل
 یک عدد دنباله ناشکسته‌ای از یک یا تعداد بیشتری اعداد دهدهی است، که یک علامت مثبت یا منفی می‌تواند پیش از آن بیاید.
 یک سمبل حرفی است که بعد از هیچ یا تعدادی کاراکتر (جز فاصله) می‌آید.
 یک لیست تعدادی پرانتز است که می‌تواند صفر یا چند عبارت در خود داشته باشد.
مثال‌های رو به رو دنباله‌هایی خوش فرم در این گرامر هستند: a b c232 (1)) ، () ، 12345)

همهٔ برنامه‌هایی که از لحاظ دستوری درست هستند، از نظر معنا درست نیستند. بسیاری از برنامه‌های درست دستوری، بد فرم هستند و با توجه به قوانین زبان؛ ممکن است (بسته به خصوصیات زبان و درست بودن پیاده‌سازی) نتیجهٔ آن‌ها خطای ترجمه یا استثنا (exception) باشد.
در برخی موارد، چنین برنامه‌هایی ممکن است رفتار نامشخصی از خود نشان دهند. حتی اگر یک برنامه در یک زبان به خوبی بیان شده باشد، ممکن است دقیقاً مطلوب نویسنده آن نبوده باشد.

به عنوان مثال در زبان طبیعی، ممکن نیست به برخی از جملات درست از لحاظ گرامری، معنای خاصی اطلاق کرد یا ممکن است جمله نادرست باشد:
 «ایده‌های بیرنگ سبز با خشم می‌خوابند.» از نظر دستوری خوش فرم است ولی معنای مورد قبولی ندارد.
 «جان یک مجرد متأهل است.» از نظر دستوری درست است، ولی معنایی را بیان می‌کند که نمی‌تواند درست باشد.
این تکّه کد در زبان C از نظر دستوری درست است، اما کاری را انجام می‌دهد که از نظر معنایی تعریف نشده‌است. (زیرا p یک اشاره‌گر خالی است، عمل p->im معنای خاصی ندارد و عمل p>>4* برای مقدارهای پیچیده بی‌معنی است)complex *p = NULL;
complex abs_p = sqrt(*p >> 4 + p->im);دستور مورد نیاز برای مشخص کردن یک زبان برنامه‌نویسی می‌تواند با جایگاهش در «سلسله مراتب چامسکی» طبقه‌بندی شود. دستور بیشتر زبان‌های برنامه‌نویسی می‌تواند به وسیلهٔ یک گرامر نوع ۲ مشخص گردد، برای نمونه، گرامرهای مستقل از متن.

 معناشناسی ایستا 
معناشناسی ایستا محدودیت‌هایی بر روی ساختار مجاز متن‌ها تعیین می‌کند که بیان آن‌ها در فرمول دستوری استاندارد مشکل یا غیرممکن است. مهم‌ترین این محدودیت‌ها به وسیله سیستم نوع‌گذاری انجام می‌شود. برخلاف باور برخی از برنامه‌نویسان محدودیت‌های اعمال شده، اعمال نشده‌اند بلکه در واقع ناشی از زیرساخت‌های آن زبان برنامه‌نویسی هستند تا سرعت پردازش را افزایش دهند و قدرت پردازش پردازنده را برای تایپ‌کستینگ‌های خودکار متعدد صرف نکنند. استفاده از روش ایستا صرفاً سرعت پردازش‌هایی را افزایش می‌دهد که در کسری از ثانیه به محاسبه حجم انبوهی از داده‌ها نیاز دارند. این موضوع بهبود پردازش برای مثال خودش را در گرافیک‌های سنگین بازی‌های کامپیوتری نشان می‌دهد همچنین برای مثال در سرورهای بک‌اند (پشتی) بانکداری با حجم انبوهی از ثبت تراکنش‌ها که از زبان ایستای جاوا استفاده می‌شود اما حتی در موضوع گرافیک جاوا به دلیل استفاده از گاربیج‌کالکشن یا جمع‌آوری زباله و البته استفاده از ماشین مجازی برای مدیریت حافظه سرعت پردازشی ++C را ندارد از طرفی استفاده دات نت از زبان میانجی IL برای پشتیبانی از زبان‌های متعدد مانند #C یا #F و کامپایل نکردن مستقیم به باینری ماشینی باعث می‌شود که سرعت پردازش #C نیز از جاوا پایین‌تر باشد اما امکانات گسترده‌تری را در زمینه‌های خاصی مانند طراحی وب یا ساخت برنامه‌های سبک‌پردازشی روی سیستم‌عامل را فراهم کند اگرچه با صرف میزان بیشتری از منابع حافظه و پردازشی همراه است.

 سیستم نوع‌گذاری 
یک سیستم نوع‌گذاری مشخص می‌کند که یک زبان برنامه‌نویسی چگونه مقادیر و عبارات را در نوع (type) دسته‌بندی می‌کند، چگونه می‌تواند آن نوع‌ها را تغییر دهد و رفتار متقابل آن‌ها چگونه‌است. این کار عموماً توضیح داده ساختارهایی که می‌توانند در آن زبان ایجاد شوند را شامل می‌شود. طراحی و مطالعه سیستم‌های نوع‌گذاری به وسیلهٔ ریاضیات قراردادی را تئوری نوع‌گذاری می‌گویند.

 زبان‌های نوع‌گذاری شده و بدون نوع‌گذاری 
یک زبان نوع‌گذاری شده‌است اگر مشخصات هر عملیات، نوع داده‌های قابل اجرا توسط آن را با نشان دادن نوع‌هایی که برای آن‌ها قابل اجرا نیست، تعیین کند. برای مثال، «این متن درون گیومه قرار دارد» یک رشته‌است. در بیشتر زبان‌های برنامه‌نویسی، تقسیم یک رشته با یک عدد معنایی ندارد. در نتیجه بیشتر زبان‌های برنامه‌نویسی مدرن ممکن است اجرای این عملیات را توسط برنامه‌ها رد کنند. در برخی زبان‌ها، عبارات بی‌معنی ممکن است هنگام ترجمه (compile) پیدا شود (چک‌کنندهٔ نوع ایستا)، و توسط کامپایلر رد شود، در حالی که در سایر برنامه‌ها، هنگام اجرا پیدا شود. (چک‌کننده نوع دینامیک) که به استثنای در حال اجرا منتج شود(runtime exception).
حالت خاص زبان‌های نوع دار زبان‌های تک نوع هستند. بیشتر این زبان‌ها اسکریپتی یا مارک آپ هستند، مانند rexx و SGML و فقط یک داده گونه دارند—غالباً رشته‌های کاراکتری که هم برای داده‌های عددی و هم برای داده‌های سمبلی کاربرد دارند.
در مقابل، یک زبان بدون نوع گذاری، مثل اکثر زبان‌های اسمبلی، این امکان را می‌دهد که هر عملیاتی روی هر داده‌ای انجام شود، که معمولاً دنباله‌ای از بیت‌ها با طول‌های متفاوت در نظر گرفته می‌شوند. زبان‌های سطح بالا که بی نوع هستند شامل زبان‌های ساده رایانه‌ای و برخی از انواع زبان‌های نسل چهارم.

در عمل، در حالیکه تعداد بسیار کمی از دیدگاه نظریه نوع، نوع‌گذاری شده تلقی می‌شوند (چک کردن یا رد کردن تمام عملیات‌ها)، بیشتر زبان‌های امروزی درجه‌ای از نوع‌گذاری را فراهم می‌کنند. بسیاری از زبان‌های تولیدکننده راهی را برای گذشتن یا موقوف کردن سیستم نوع فراهم می‌کنند.

 نوع‌گذاری ایستا و پویا 
در نوع‌گذاری ایستا تمام عبارات نوع‌های خود را قبل از اجرای برنامه تعیین می‌کنند (معمولاً در زمان کامپایل). برای مثال، ۱ و (۲+۲) عبارات عددی هستند؛ آن‌ها نمی‌توانند به تابعی که نیاز به یک رشته دارد داده شوند، یا در متغیری که تعریف شده تا تاریخ را نگه دارد، ذخیره شوند.

زبان‌های نوع‌گذاری شده ایستا می‌توانند با مانیفست نوع‌گذاری شوند یا با استفاده از نوع استنباط شوند. در حالت اول، برنامه‌نویس بیشتر صریحاً نوع‌ها را در جایگاه‌های متنی مشخص می‌نویسد (برای مثال، در تعریف متغیرها). در حالت دوم، کامپایلر نوع عبارات و تعریف‌ها را بر اساس متن استنباط می‌کند. بیشتر زبان‌های مسیر اصلی (mainstream) ایستا نوع‌گذاری شده‌اند، مانند #C++ ,C و Java که با مانیفست نوع‌گذاری می‌شوند.

 نوع‌گذاری قوی و ضعیف 
نوع‌گذاری ضعیف این امکان را ایجاد می‌کند که با متغیری به جای متغیری دیگر برخورد شود، برای مثال رفتار با یک رشته به عنوان یک عدد. این ویژگی بعضی اوقات ممکن است مفید باشد، اما ممکن است باعث ایجاد برخی مشکلات برنامه شود که موقع کامپایل و حتی اجرا پنهان بمانند.

نوع‌گذاری قوی مانع رخ دادن مشکل فوق می‌شود. تلاش برای انجام عملیات روی نوع نادرست متغیر منجر به رخ دادن خطا می‌شود. زبان‌هایی که نوع‌گذاری قوی دارند غالباً با نام «نوع-امن» یا امن شناخته می‌شوند.
تمام تعاریف جایگزین برای «ضعیف نوع‌گذاری شده» به زبان‌ها اشاره می‌کند، مانند C++ ,JavaScript و Perl که اجازه تعداد زیادی تبدیل نوع داخلی را می‌دهند. در جاوااسکریپت، برای مثال، عبارت ۲*x به صورت ضمنی x را به عدد تبدیل می‌کند، و این تبدیل موفقیت‌آمیز خواهد بود حتی اگر x خالی، تعریف نشده، یک آرایه، یا رشته‌ای از حروف باشد. چنین تبدیل‌های ضمنی در بیشتر موارد مفیدند، اما خطاهای برنامه‌نویسی را پنهان می‌کنند.

قوی و ایستا در حال حاضر عموماً دو مفهوم متعامد فرض می‌شوند، اما استفاده در ادبیات تفاوت دارد، برخی عبارت «قوی نوع‌گذاری شده» را به کار می‌برند و منظورشان قوی، ایستایی نوع‌گذاری شده‌است، و یا، حتی گیج‌کننده‌تر، منظورشان همان ایستایی نوع‌گذاری شده‌است؛ بنابراین C هم قوی نوع‌گذاری شده و هم ضعیف و ایستایی نوع‌گذاری شده نامیده می‌شود.

 معناشناسی اجرا 
وقتی که داده مشخص شد، ماشین باید هدایت شود تا عملیات‌ها را روی داده انجام دهد. معناشناسی اجرا ی یک زبان تعیین می‌کند که چگونه و چه زمانی ساختارهای گوناگون یک زبان باید رفتار برنامه را ایجاد کنند.

برای مثال، معناشناسی ممکن است استراتژی را که به وسیله آن عبارات ارزیابی می‌شوند را تعریف کند یا حالتی را که ساختارهای کنترلی تحت شرایطی دستورها را اجرا می‌کنند.

 کتابخانهٔ هسته 
بیشتر زبان‌های برنامه‌نویسی یک کتابخانهٔ هسته مرتبط دارند (گاهی اوقات "کتابخانهٔ استاندارد" نامیده می‌شوند، مخصوصاً وقتی که به عنوان قسمتی از یک زبان استاندارد ارائه شده باشند)، که به‌طور قراردادی توسط تمام پیاده‌سازی‌های زبان در دسترس قرار گرفته باشند. کتابخانهٔ هسته معمولاً تعریف الگوریتم‌ها، داده ساختارها و مکانیزم‌های ورودی و خروجی پرکاربرد را در خود دارد.
کاربران یک زبان، در بیشتر موارد با کتابخانهٔ هسته به عنوان قسمتی از آن رفتار می‌کنند، اگرچه طراحان ممکن است با آن به صورت یک مفهوم مجزا رفتار کرده باشند. بسیاری از ویژگی‌های زبان هسته‌ای را مشخص می‌کنند که باید در تمام پیاده‌سازی‌ها موجود باشند، و در زبان‌های استاندارد شده این کتابخانهٔ هسته ممکن است نیاز باشد؛ بنابراین خط بین زبان و کتابخانهٔ هستهٔ آن از زبانی به زبان دیگر متفاوت است. در واقع، برخی زبان‌ها به گونه‌ای تعریف شده‌اند که برخی از ساختارهای دستوری بدون اشاره به کتابخانه هسته قابل استفاده نیستند.
برای مثال در جاوا، یک رشته به عنوان نمونه‌ای از کلاس “java.lang.String” تعریف شده‌است؛ به‌طور مشابه، در سمال تاک (smalltalk) یک تابع بی‌نام (یک "بلاک") نمونه‌ای از کلاس BlockContext کتابخانه می‌سازد. به‌طور معکوس، Scheme دارای چندین زیرمجموعه مرتبط برای ایجاد سایر ماکروهای زبان می‌باشد، و در نتیجه طراحان زبان حتی این زحمت را نیز تحمل نمی‌کنند که بگویند کدام قسمت زبان به عنوان ساختارهای زبان باید پیاده‌سازی شوند، و کدام یک به عنوان بخشی از کتابخانه.

 مدیریت منابع و نشت حافظه 
مدیریت منابع به دوشاخه پردازش و حافظه (موقت یا دائم یا دورگه (موقت مجازی)) تقسیم می‌شود و در یک عبارت خلاصه می‌شود: در ایده‌آل‌ترین حالت صرفه‌جویی در حافظه، میزان پردازش را افزایش می‌دهد و صرفه‌جویی در پردازش، حافظه مصرفی را افزایش می‌دهد (این موضوع در بانک‌های اطلاعاتی با عنوان نرمالیزیشن و دینرمالیزیشن شناخته می‌شود). مقدار حافظه اختصاص داده شده برای یک متغیر عدد کوتاه ۸ بیتی در زبان ایستا قابل مقایسه با یک متغیر طولانی ۳۲بیتی نیست که این موضوع در زبان ایستا به صراحت و مستقیم توسط کد نوشته‌شده برنامه‌نویس تعیین می‌شود (در زبان پویا نیاز به اجرای کد زیرساختاری اضافی کوچک دیگری هست تا تشخیص دهد که چه نوع مقداری به این متغیر اختصاص داده شده؟ استرینگ رشته یا عدد بزرگ یا کوچک؟). این تفاوت ظرفیت عددها در زمان تفکیک برنامه‌های ۶۴بیتی در مقایسه با برنامه‌های ۳۲بیتی حتی برای عموم مردم کاملاً فاحش می‌شود (با اشاره به این نکته حاشیه‌ای که برنامه‌های ۳۲بیتی به دلیل محدودیت عددی توان اندازه‌گیری حافظه بیشتر از ۴میلیارد و اندی بایت را ندارند که معادل ۴گیگابایت است که در مبنای ۲ به توان ۳۲ محاسبه شده باشد در نتیجه سیستم‌عامل ۳۲بیتی نمی‌تواند روی یک سیستم با رَم بیش از ۴ گیگابایت نصب شود).

تفاوت زبان‌های پویا با ایستا فقط در تعریف نوع متغیر نیست بلکه همان‌طور که دربارهٔ اعداد مطرح شد به زمینه مدیریت حافظه یا مموری منیجمنت نیز کشیده می‌شود همچنین بارگذاری خودکار کتابخانه‌ها و گسترده کردن کتابخانه‌های محیط اجرای برنامه. البته زبان‌های ایستای مدرن مانند C# با زبان میانجی IL یا جاوا و ماشین مجازی‌اش از مدیریت حافظه بهره می‌برند و به نوعی دورگه و هیبرید هستند تا تعادلی بین مدیریت حافظه و مدیریت پردازش را بدون تایپ‌کستیگ ایجاد کنند.

تفاوت سرعت پردازش زبان‌های ایستا و پویا در برنامه‌هایی که نیاز به پردازش‌های بسیار حجیم در مدت زمان بسیار کوتاه دارند خودش را نشان می‌دهد بنابراین تفاوت سرعت پردازش در مورد حتی وبگاه‌های بسیار شلوغ آنقدر نیست که امکانات فراهم شده توسط یک زبان سطح بالا مانند php یا python را فدای سرعت C++ کنند البته برای مثال فیسبوک مجبور شد که php را بواسطه c++ بر روی facebook hiphop گسترش دهد تا به سرعت پردازش مطلوب خودش برسد. برای مثال دربارهٔ python توصیه شده‌است که حلقه‌های چرخشی روی حجم بالای داده را بواسطه لوپ خود پایتون و با اندیس index انجام ندهید بلکه یک آرایه array تهیه کرده و چرخش را به زیرساخت C++ آن واگذار کنید.

اما مسئله مدیریت حافظه و نشت آن یا memory leakage از آنجاست که در زمان اجرای برنامه (runtime) ابتدا فضایی از حافظه به نام کداسپیس به کد اختصاص داده می‌شود و به بقیه حافظه در دسترس heap گفته می‌شود. مسئولیت استفاده و تضمین خالی کردن بخش اشغال‌شده از heap پس از پایان کار به عهده خود برنامه‌نویس است در غیر اینصورت برنامه ممکن است دچار نشت حافظه شود. در زمان ران‌تایم جدولی از کداسپیس درون ساختار زبان برای تعیین حافظه مورد استفاده هر بخش از کد (مثلاً یک تابع یا فانکشن) اختصاص داده می‌شود که به هر بخش از آن اصطلاحاً Scope گفته می‌شود که تعیین می‌کند که کدام متغیرها توسط کدام بخش از کد استفاده می‌شوند تا در آغاز یک scope آن متغیرها درون محیط مثلاً یک تابع ایجاد شوند و پس از اجرا کاملاً پاک شوند (کسانی که در محیط ساده بورن شل کار کرده‌اند با این موضوع به خوبی آشنا می‌شوند). اما در زمان استفاده از رفرنس خارجی در قالب pointer (اختصاصی زبان C++) آن متغیری که به ظاهر در محیط اسکوپ استفاده می‌شود در واقع فقط یک میان‌بر رفرنس است به پوینتری که فضایی را روی حافظه تعیین کرده‌است که خارج از محدوده اسکوپ مثلاً تابع فعلی ما قرار دارد در نتیجه با پایان کار فانکشن ما، فضای اختصاصی آن پوینتر تخلیه نمی‌شود بلکه فقط متغیر رفرنسی که به آن اشاره می‌کرده پاک می‌شود و نشت حافظه رخ می‌دهد (به آن pointer که هیچ متغیر رفرنسی نداشته باشد پوینتر وحشی یا wild گفته می‌شود) و این پوینتر می‌تواند یک شی بانک اطلاعاتی دارای حجم انبوهی از داده‌های استخراج شده باشد یا یک شی ارتباطی بانک اطلاعاتی که از دسترس خارج شده‌اند اما فضای حافظه را تا زمان بازبودن برنامه اشغال می‌کنند. رفرنس‌های پوینتر حتی در زبان‌های سطح بالا مانند php و python یا C# هنوز در لایه زیرین ناپیدا استفاده می‌شوند برای انتقال متغیرها در سراسر برنامه اما زبان سطح بالا تعداد رفرنس‌های موجود به هر پوینتر را حفظ می‌کند و زمانی که این تعداد صفر بشود زمان مرگ پوینتر و تخلیه آن فرا رسیده یا آن را به سطل زباله گاربیج‌کالکشن می‌فرستد تا همه آن‌ها را با هم و در یک نوبت تخلیه کند و از بار پردازشی اضافه ناشی از تخلیه مکرر بکاهد اگرچه تعداد نوبت‌های تخلیه گاربیج‌کالکشن در تنظیمات برنامه یا سرور ماشین مجازی قابل تنظیم است.

 طراحی و پیاده‌سازی 
زبان برنامه‌نویسی یک مکانیزم ساخت یافته برای تعریف داده‌ها، و عملیات یا تبدیل‌هایی که ممکن است به‌طور اتوماتیک روی آن داده انجام شوند، فراهم می‌کند. یک برنامه‌نویس از انتزاعات آماده در زبان استفاده می‌کند تا مفاهیم به کار رفته در محاسبات را بیان کند. این مفاهیم به عنوان یک مجموعه از ساده‌ترین عناصر موجود بیان می‌شوند (مفاهیم ابتدایی نامیده می‌شوند). زبان‌های برنامه‌نویسی با بیشتر زبان‌های انسانی تفاوتی دارد و آن این است که نیاز به بیان دقیق تر و کامل تری دارد. هنگام استفاده از زبان‌های طبیعی برای ارتباط با دیگر انسان‌ها، نویسندگان و گویندگان می‌توانند مبهم باشند و اشتباهات کوچک داشته باشند، و همچنان انتظار داشته باشند که مخاطب آن‌ها متوجه شده باشد. اگرچه، مجازا، رایانه‌ها «دقیقاً آنچه که به آن‌ها گفته شده را انجام می‌دهند.» و نمی‌توانند «بفهمند» که نویسنده دقیقاً چه کدی مد نظر داشته‌است] البته امروزه برنامه‌هایی برای انجام این کار تولید شده‌اند و تلاش‌های بسیاری در این زمینه انجام شده ولی هنوز به نتیجهٔ رضایت بخشی نرسیده‌است[. ترکیب تعریف زبان، یک برنامه، و ورودی برنامه به‌طور کامل رفتار خروجی را به هنگام اجرای برنامه (در محدوده کنترل آن برنامه) مشخص می‌کند. برنامه‌های یک رایانه ممکن است در یک فرایند ناپیوسته بدون دخالت انسان اجرا شوند، یا یک کاربر ممکن است دستورهای را در یک مرحله فعل و انفعال مفسر تایپ کند. در این حالت «دستور»ها همان برنامه‌ها هستند، که اجرای آن‌ها زنجیروار به هم مرتبطند. به زبانی که برای دستور دادن به برنامه‌ای استفاده می‌شود، زبان اسکریپت می‌گویند. بسیاری از زبان‌ها کنار گذاشته شده‌اند، برای رفع نیازهای جدید جایگزین شده‌اند، با برنامه‌های دیگر ترکیب شده‌اند و در نهایت استعمال آن‌ها متوقف شده‌است. با وجود اینکه تلاش‌هایی برای طراحی یک زبان رایانه« کامل» شده‌است که تمام اهداف را تحت پوشش قرار دهد، هیچ‌یک نتوانستند به‌طور کلی این جایگاه را پر کنند. نیاز به زبان‌های رایانه‌ای گسترده از گستردگی زمینه‌هایی که زبان‌ها استفاده می‌شوند، ناشی می‌شود:
 محدوده برنامه‌ها از متون بسیار کوچک نوشته شده توسط افراد عادی تا سیستم‌های بسیار بزرگ نوشته شده توسط صدها برنامه‌نویس است.
 توانایی برنامه‌نویس‌ها: از تازه‌کارهایی که بیش از هر چیز به سادگی نیاز دارند تا حرفه‌ای‌هایی که با پیچیدگی قابل توجهی کنار می‌آیند.
 برنامه‌ها باید سرعت، اندازه و سادگی را بسته به سیستم‌ها از ریزپردازنده‌ها تا ابر رایانه‌ها متناسب نگه دارند.
 برنامه‌ها ممکن است یک بار نوشته شوند و تا نسل‌ها تغییر نکنند، یا ممکن است پیوسته اصلاح شوند.
 در نهایت، برنامه‌نویس‌ها ممکن است در علایق متفاوت باشند: آن‌ها ممکن است به بیان مسائل با زبانی خاص خو گرفته باشند.

یک سیر رایج در گسترش زبان‌های برنامه‌نویسی این است که قابلیت حل مسائلی با درجات انتزاعی بالاتری را اضافه کنند. زبان‌های برنامه‌نویسی اولیه به سخت‌افزار رایانه گره خورده بودند. همان‌طور که زبان‌های برنامه‌نویسی جدید گسترش پیدا کرده‌اند، ویژگی‌هایی به برنامه‌ها افزوده شده که به برنامه‌نویس اجازه دهد که ایده‌هایی که از ترجمه ساده به دستورهای سخت‌افزار دورتر هستند نیز استفاده کند. چون برنامه‌نویس‌ها کمتر به پیچیدگی رایانه محدود شده‌اند، برنامه‌های آن‌ها می‌تواند محاسبات بیشتری با تلاش کمتر از سوی برنامه‌نویس انجام دهند. این به آن‌ها این امکان را می‌دهد که کارایی بیشتر در واحد زمان داشته باشند.

«پردازنده‌های زبان طبیعی» به عنوان راهی برای ازبین بردن نیاز به زبان‌های اختصاصی برنامه‌نویسی پیشنهاد شده‌اند. هرچند، این هدف دور است و فواید آن قابل بحث است. «ادسگر دیجسترا» موافق بود که استفاده از یک زبان رسمی برای جلوگیری از مقدمه‌سازی ساختارهای بی‌معنی واجب است، و زبان برنامه‌نویسی طبیعی را با عنوان «احمقانه» رد کرد، «آلن پرلیس» نیز مشابهاً این ایده را رد کرد. مطابق با متدولوژی نامتجانس استفاده شده توسط langpop.com در سال ۲۰۰۸، ۱۲ زبان پرکاربرد عبارتند از: C, C++, C#, Java, JavaScript, Perl, PHP, Python, Ruby, Shell, SQL, and Visual Basic

طراحان زبان و کاربران باید مصنوعاتی ایجاد کنند تا برنامه‌نویسی را در عمل ممکن سازند و کنترل کنند. مهم‌ترین این مصنوعات خصوصیات و پیاده‌سازی‌های زبان هستند.

 مشخصات 
خصوصیات یک زبان برنامه‌نویسی باید تعریفی فراهم کند که کاربران و پیاده‌کننده‌های زبان می‌توانند از آن استفاده کنند تا مشخص کنند کد منبع یک برنامه در آن زبان درست و معتبر است یا خیر، اگر اینطور باشد رفتار او چگونه خواهد بود.

مشخصات زبان برنامه‌نویسی می‌تواند اشکال مختلفی داشته باشد، از جمله موارد زیر:
 تعریف صریح دستور، معناشناسی ایستا، و معناشناسی اجرای زبان. درحالیکه دستور معمولاً با یک معناشناسی قراردادی مشخص می‌شود، تعاریف معناشناسی ممکن است در زبان طبیعی نوشته شده باشند (مثل زبان C)، یا معناشناسی قراردادی (مثل StandardML ,Scheme)
 توضیح رفتار یک مترجم برای زبان (مثل C,fortran). دستور و معناشناسی یک زبان باید از این توضیح استنتاج شوند، که ممکن است به زبان طبیعی یا قراردادی نوشته شود.
 پیاده‌سازی منبع یا مدل. گاهی اوقات در زبان‌های مشخص شده (مثل: prolog,ANSI REXX). دستور و معناشناسی صریحاً در رفتار پیاده‌سازی مدل موجودند.

 پیاده‌سازی 
پیاده‌سازی یک زبان برنامه‌نویسی امکان اجرای آن برنامه را روی پیکربندی مشخصی از سخت‌افزار و نرم‌افزار را فراهم می‌کند. به‌طور وسیع، دو راه رسیدن به پیاده‌سازی زبان برنامه‌نویسی وجود دارد. کامپایل کردن و تفسیر کردن. به‌طور کلی با هر بک از ابن دو روش می‌توان یک زبان را پیاده‌سازی کرد.

خروجی یک کامپایلر ممکن است با سخت‌افزار یا برنامه‌ای به نام مفسر اجرا شود. در برخی پیاده‌سازی‌ها که از مفسر استفاده می‌شود، مرز مشخصی بین کامپایل و تفسیر وجود ندارد. برای مثال، برخی پیاده‌سازی‌های زبان برنامه‌نویسی بیسیک کامپایل می‌کنند و سپس کد را خط به خط اجرا می‌کنند.

برنامه‌هایی که مستقیماً روی سخت‌افزار اجرا می‌شوند، چندین برابر سریعتر از برنامه‌هایی که در نرم‌افزار تفسیر می‌شوند اجرا می‌شوند.

یک تکنیک برای بهبود عملکرد برنامه‌های تفسیر شده کامپایل در لحظه آن است. در این روش ماشین مجازی، دقیقاً قبل از اجرا، بلوک‌های کدهای بایتی که قرار است استفاده شوند را برای اجرای مستقیم روی سخت‌افزار ترجمه می‌کند

 زبان‌های اختصاصی 
اگرچه بیشترین زبان‌های برنامه‌نویسی متداول دارای مشخصات و پیاده‌سازی‌های کاملاً باز هستند، بسیاری از زبان‌های برنامه‌نویسی فقط به عنوان زبان‌های برنامه‌نویسی اختصاصی با اجرای فقط از یک فروشنده منفرد موجود هستند، که ممکن است ادعا کنند چنین یک زبان اختصاصی خاصیت معنوی آنها است. زبان‌های برنامه‌نویسی اختصاصی معمولاً زبان‌های خاص دامنه یا زبان‌های برنامه‌نویسی داخلی برای یک محصول واحد هستند. برخی از زبان‌های اختصاصی فقط در داخل یک فروشنده استفاده می‌شوند، در حالی که برخی دیگر در دسترس کاربران خارجی است.

برخی از زبان‌های برنامه‌نویسی در مرز بین اختصاصی و آزاد وجود دارند. به عنوان مثال، شرکت Oracle ادعا می‌کند حقوق اختصاصی برخی از جنبه‌های زبان برنامه‌نویسی جاوا، و زبان برنامه‌نویسی #C مایکروسافت، که پیاده‌سازی‌های بیشتری در اکثر بخش‌های سیستم دارد، همچنین دارای اجرای مشترک زبان مشترک (CLR) به عنوان یک محیط بسته‌است.

بسیاری از زبان‌های اختصاصی، علی‌رغم ماهیت اختصاصی، به‌طور گسترده مورد استفاده قرار می‌گیرند. مثال‌ها شامل MATLAB, VBScript و Wolfram Language هستند. برخی از زبان‌ها ممکن است انتقال از بسته به باز را تغییر دهند. به عنوان مثال، ارلانگ در ابتدا زبان برنامه‌نویسی داخلی اریکسون بود.

 کاربرد 
هزاران زبان مختلف برنامه‌نویسی، به‌طور عمده در زمینهٔ محاسبات ایجاد شده‌اند. پروژه‌های نرم‌افزاری انفرادی معمولاً از پنج زبان برنامه‌نویسی یا بیشتر استفاده می‌کنند.

زبان‌های برنامه‌نویسی با بسیاری از اشکال دیگر بیان انسان متفاوتند زیرا نیاز به درجهٔ دقت و صحت بیشتری دارند. هنگام استفاده از یک زبان طبیعی برای برقراری ارتباط با افراد دیگر، نویسندگان و گویندگان بشر می‌توانند مبهم باشند و خطاهای کوچکی مرتکب شوند و همچنان انتظار دارند که هدف آنها درک شود. با این حال، به‌طور تصویری، رایانه‌ها «دقیقاً کاری را که به آنها گفته می‌شود انجام دهند» انجام می‌دهند و نمی‌توانند «بفهمند» چه برنامه‌ای را برای برنامه‌نویسی برنامه‌نویس نوشته‌است. ترکیب تعریف زبان، یک برنامه و ورودی‌های برنامه باید به‌طور کامل رفتارهای خارجی را که هنگام اجرای برنامه رخ می‌دهد، در دامنه کنترل آن برنامه مشخص کند. از طرف دیگر، ایده‌های مربوط به یک الگوریتم را می‌توان بدون استفاده از دقت مورد نیاز برای اجرای با استفاده از pseudocode که به زبان طبیعی با کد نوشته شده با یک زبان برنامه‌نویسی متصل می‌شود، به انسان‌ها انتقال داد.

یک زبان برنامه‌نویسی یک مکانیسم ساختاری برای تعریف بخش‌هایی از داده‌ها و عملیات یا تحولاتی که ممکن است به‌طور خودکار بر روی آن داده‌ها انجام شود فراهم می‌کند. یک برنامه‌نویس از انتزاعات موجود در زبان برای نشان دادن مفاهیم درگیر در یک محاسبه استفاده می‌کند. این مفاهیم به عنوان مجموعه ای از ساده‌ترین عناصر موجود (به نام ابتدایی) ارائه می‌شوند. برنامه‌نویسی فرایندی است که توسط آن برنامه‌نویسان این اولیه را برای تهیه برنامه‌های جدید ترکیب می‌کنند، یا برنامه‌های موجود را با کاربردهای جدید یا یک محیط در حال تغییر تطبیق می‌دهند.

برنامه‌های رایانه ممکن است در یک فرایند دسته ای بدون تعامل انسان اجرا شود، یا ممکن است یک کاربر دستورالعمل‌ها را در یک جلسه تعاملی یک مترجم تایپ کند. در این حالت «دستورها» صرفاً برنامه‌هایی هستند که اجرای آنها با هم زنجیر شده‌است. هنگامی‌که یک زبان می‌تواند دستورها خود را از طریق یک مترجم اجرا کند (مانند پوسته یونیکس یا دیگر رابط خط فرمان)، بدون تدوین، به آن اسکریپت می‌گویند.

 اندازه‌گیری میزان استفاده از زبان 
مشکل است که مشخص کنیم کدام زبان برنامه‌نویسی بیشتر مورد استفاده‌است، و اینکه کاربرد چه معنی می‌دهد با توجه به زمینه تغییر می‌کند. یک زبان ممکن است زمان بیشتری از برنامه‌نویس بگیرد، زبان دیگر ممکن است خطوط بیشتری داشته باشد، و دیگری ممکن است زمان بیشتری از پردازنده را مصرف کند. برخی زبان‌ها برای کاربردهای خاص بسیار محبوبند. برای مثال: کوبول همچنان در مراکز داده متحد، غالباً روی کامپیوترهای بزرگ توانا است؛ fortran در مهندسی برنامه‌های کاربردی، Ada در هوا و فضا، حمل و نقل، نظامی، برنامه‌های واقعی و جاسازی شده در زمان واقعی؛ و C در برنامه‌های تعبیه شده و سیستم‌های عامل؛ و بقیه برنامه‌ها معمولاً برای نوشتن انواع دیگر برنامه‌ها کاربرد دارند..

روش‌های مختلفی برای سنجش محبوبیت زبان‌ها، هر یک متناسب یا یک ویژگی محوری متفاوت پیشنهاد شده‌است:
 شمارش تعداد آگهی‌های شغلی که زبان را ذکر می‌کنند
 تعداد کتابهای فروخته شده که زبان را آموزش می‌دهد یا توصیف می‌کند
 تخمین تعداد خطوط موجود کد که به زبان نوشته شده‌اند - که ممکن است زبان‌هایی را که غالباً در جستجوی عمومی یافت نمی‌شوند دست کم بگیرند
 شمارش ارجاع‌های زبان (برای مثال، به اسم زبان) در موتورهای جستجوهای اینترنت.

وب سایت stackify.com با تلفیق و میانگین اطلاعات از سایت‌های مختلف اینترنتی، ده زبان محبوب برنامه‌نویسی را به صورت زیر گزارش داد:

Java

C

++C

Python

#C

JavaScript

VB

NET.

R

PHP

MATLAB

 گویشها، طعم دهنده‌ها و پیاده‌سازی‌ها 
گویش یک زبان برنامه‌نویسی یا یک زبان تبادل اطلاعات یک تغییر یا گسترش زبان (نسبتاً کوچک) است که ماهیت ذاتی آن را تغییر نمی‌دهد. با زبان‌هایی مانند Scheme و Forth، ممکن است استانداردها توسط مجریان ناکافی، ناکافی یا نامشروع تلقی شوند، بنابراین آنها در بیشتر موارد با ایجاد یک گویش جدید از استاندارد منحرف می‌شوند. در موارد دیگر، یک گویش برای استفاده در یک زبان خاص دامنه، بیشتر زیر مجموعه ایجاد می‌شود. در دنیای Lisp، بیشتر زبان‌هایی که از اصطلاحات اصطلاحاتی اصطلاحات S و اصطلاحات شبیه به Lisp استفاده می‌کنند، لهجه‌های Lisp در نظر گرفته می‌شوند، گرچه تفاوت‌های وحشیانه‌ای دارند، به عنوان مثال، راکت و کلوژ. از آنجا که معمول است که یک زبان چند لهجه داشته باشد، پیدا کردن اسناد مناسب برای یک برنامه‌نویس بی‌تجربه بسیار دشوار است. زبان برنامه‌نویسی BASIC گویش‌های زیادی دارد.

انفجار گویش‌های چهارم منجر به این جمله شد که «اگر یک مورد دیگر را دیده‌اید … یکی دیگر را دیده‌اید.»

 طبقه‌بندی‌ها 
هیچ برنامهٔ غالبی برای دسته‌بندی زبان‌های برنامه‌نویسی وجود ندارد. یک زبان مشخص معمولاً یک زبان اجدادی واحدی ندارد. زبان‌ها معمولاً با ترکیب عنصرهای چند زبان پیشینه به وجود می‌آیند که هر بار ایده‌های جدید در گردشند. ایده‌هایی که در یک زبان ایجاد می‌شوند در یک خانواده از زبان‌های مرتبط پخش می‌شوند، و سپس از بین خلأهای بین خانواده‌ها منتقل شده و در خانواده‌های دیگر ظاهر می‌شوند.

این حقیقت که این دسته‌بندی ممکن است در راستای محورهای مختلف انجام شوند، این وظیفه را پیچیده‌تر می‌کند؛ برای مثال، جاوا هم یک زبان شیءگرا (چون به برنامه‌نویسی شیءگرا تشویق می‌کند) و هم یک زبان هم‌زمان (چون ساختارهای داخلی برای اجرای چندین جریان موازی دارد) است. پایتون یک زبان اسکریپتی شیءگرا است.

در نگاه کلی، زبان‌های برنامه‌نویسی به مثال‌های برنامه‌نویسی و یک دسته‌بندی بر اساس محدودهٔ استفاده تقسیم می‌شوند. مثال‌ها شامل برنامه‌نویسی رویه‌ای، برنامه‌نویسی شیءگرا، برنامه‌نویسی کاربردی، و برنامه‌نویسی منطقی؛ برخی زبان‌ها ترکیب چند مثالند. یک زبان اسمبلی مثالی از یک مدل مستقیم متضمن معماری ماشین نیست. با توجه به هدف، زبان‌های برنامه‌نویسی ممکن است همه منظوره باشند، زبان‌های برنامه‌نویسی سیستمی، زبان‌های اسکریپتی، زبان‌های خاص دامنه، زبان‌های همزمان/ گسترده (و یا ترکیب اینها). برخی زبان‌های همه منظوره تا حد زیادی برای اهداف آموزشی طراحی شده‌اند.

یک زبان برنامه‌نویسی ممکن است با فاکتورهای غیر مرتبط به مثال‌های برنامه‌نویسی دسته‌بندی شود. برای مثال، بیشتر زبان‌های برنامه‌نویسی کلمات کلیدی زبان انگلیسی را استفاده می‌کنند، در حالیکه تعداد کمی این کار را نمی‌کنند. سایر زبان‌ها ممکن است براساس داخلی بودن یا نبودن دسته‌بندی شوند.

 منابع 

 مفاهیم مربوط به زبان‌های برنامه‌نویسی 
 

رده:رده‌بندی زبان‌های برنامه‌نویسی
رده:زبان‌های برنامه‌نویسی
رده:موضوعات مربوط به زبان‌های برنامه‌نویسی
رده:نشانه‌گذاری
رده:ویکی‌سازی رباتیک