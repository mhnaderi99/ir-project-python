مترجم، همگردان، یا کامپایلر  برنامه یا مجموعه‌ای از برنامه‌های کامپیوتری است که متنی از زبان برنامه‌نویسی سطح بالا (زبان مبدأ) را به زبانی سطح پایین (زبان مقصد)، مثل اسمبلی یا زبان سطح ماشین، تبدیل می‌کند. خروجی این برنامه ممکن است برای پردازش شدن توسط برنامه دیگری مثل پیونددهنده مناسب باشد یا فایل متنی باشد که انسان نیز بتواند آن را بخواند. به این علت فرودبر نامگذاری شده‌است که کد با زبان سطح بالا را به کد زبان سطح پایین تبدیل می‌کند بدون این که در رفتار کد تغییری حاصل شود. به عمل compile کردن فرودش گفته می‌شود.

مهم‌ترین علت استفاده از ترجمه کد مبدأ، ایجاد برنامه اجرایی می‌باشد. برعکس برنامه‌ای که زبان برنامه‌نویسی سطح پایین را به بالاتر تبدیل می‌کند را مترجم‌وارون گوییم.

ترجمه کامل کد منبع برنامه‌ای از یک زبان سطح بالا به کد شیء، پیش از اجرای برنامه را هم‌گردانی یا کامپایل می‌گویند.

به بیان ساده، کامپایلر برنامه‌ای است که یک برنامه نوشته شده در یک زبان خاص ساخت‌یافته را خوانده و آن را به یک برنامه مقصد (Target Language) تبدیل می‌نماید. در یکی از مهم‌ترین پروسه‌های این تبدیل، کامپایلر وجود خطا را در برنامه مبدأ اعلام می‌نماید.

چپ|بندانگشتی|شمایی از یک کامپایلر

در اولین نگاه، تنوع کامپایلرها ممکن است به چشم نیاید. تعداد بسیار زیادی زبان‌های منبع وجود دارند که دامنه آن‌ها از زبان‌های شناخته شده مانند فرترن و پاسکال تا زبان‌های خاص منظوره گسترده‌است. زبان‌های مقصد نیز گستردگی متناظر با این زبان‌ها دارند. یک زبان مقصد ممکن است زبان برنامه‌سازی دیگر یا زبان ماشین یا … باشد.

کامپایلرها به انواع تک‌گذره، چند گذره، باردهی و اجرا، بهینه‌ساز، غلط‌یاب و … بسته با عمل انجام شده تقسیم می‌شوند. علی‌رغم این تنوع اعمال اساسی که هر کامپایلر بایستی انجام دهد، مشابه هم می‌باشند.

دانسته‌های ما دربارهٔ سازمان‌بندی و نوشتن کامپایلر نسبت به زمانی که اولین کامپایلرها در اوایل دهه ۱۹۵۰ ایجاد شدند، بسیار افزایش یافته‌است. تخمین تاریخ دقیق ساخت اولین کامپایلر عمل آسانی نیست، زیرا گروه‌های متفاوتی نسبت به ساخت کامپایلرها در آن زمان اقدام نموده‌اند. اولین کارهایی که در ساخت کامپایلرها انجام شد، تبدیل فرمول‌های ریاضی به زبان ماشین بود.

در اواسط دهه ۱۹۵۰ کامپایلرها به عنوان برنامه‌هایی دشوار شناخته شده بودند. اولین کامپایلر فرترن، به عنوان مثال ۱۸ سال زمان برای طراحی صرف کرد. از آن زمان روش‌های سیستماتیک برای استفاده از بسیاری اعمال مهم حین عمل کامپایل ابداع شده‌است. همچنین زبان‌های پیاده‌سازی خوب، محیط‌های برنامه‌نویسی و ابزارهای نرم‌افزاری مناسب ایجاد شده‌اند. با کمک این پیشرفت‌ها یک کامپایلر را می‌توان حتی به عنوان پروژه درسی در یک ترم تحصیلی دانشجویی طراحی کرد.

 تاریخچه 
در اواخر دهه ۱۹۵۰ میلادی ماشین‌های دارای زبان‌های برنامه‌نویسی رواج یافتند و کامپایلرهای آزمایشی ایجاد شدند. زبان فرترن به سرپرستی جان باکوس در شرکت آی‌بی‌ام به عنوان اولین کامپایلر کامل در سال ۱۹۵۷ تولید شد. کوبول اولین زبان کامپایلی با معماری چندگانه در سال ۱۹۶۰ تولید شد. در طی دهه ۶۰ کامپایلرهای زیادی تولید شد اما بر روی کیفیت کامپایلرها کمتر فکر می‌شد.
هم‌زمان با تکامل زبان‌های برنامه‌سازی و افزایش قدرت کامپیوترها، کامپایلرها هرچه بیشتر پیچیده می‌شدند.

یک کامپایلر خود برنامه‌ای است که توسط زبان پیاده‌ساز تولید شده‌است. اولین کامپایلر خود محور که می‌توانست کد خود را کامپایل کند برای زبان Lisp و توسط Hart و Levin در سال ۱۹۶۲ و در مؤسسه فناوری ماساچوست ایجاد شد. در دهه ۷۰ از زبان‌های سطح بالایی مثل پاسکال و سی جهت نوشتن کامپایلرها استفاده شد. ساخت کامپایلرهای خود محور دارای مشکل راه‌اندازی است، چونکه هر کامپایلری باید توسط کامپایلر نوشته شده‌ای به زبان دیگر کامپایل شود یا برای این مشکل دست به دامن مفسری بشود.

ساختار کامپایلرها و کامپایلر بهینه‌ساز امروزه بخشی از برنامه درسی دانشجویان کامپیوتر است. برخی کامپایلرها به منظور آموزشی برای زبان‌های برنامه‌نویسی تولید می‌گردد. مثلاً کامپایلر PL/۰ توسط Niklaus Wirth برای آموزش در دهه ۱۹۷۰ به کار رفت. به علت سادگی و دلایل زیر هنوز برای آموزش مورد استفاده قرار می‌گیرد:
 توسعه گام به گام برنامه
 به‌کارگیری پارسرهای بازگشتی
 استفاده از EBNF جهت تعریف نحو زبان
 استفاده از P-Code در جریان تولید کد خروجی قابل حمل
 نمایش T-diagram جهت تعارف رسمی

در تاریخچه کامپایلر سه دوره می‌توان در نظر گرفت:

از ۱۹۴۵تا۱۹۶۰:تولید کد(m.h.sزبان ماشیی)

در این دوره، زبان‌ها به تدریج به وجود آمدند و ماشین‌ها چندان متعارف نبودند. مسئله این بود که چگونه باید کدی را برای یک ماشین تولید کرد. با توجه به اینکه برنامه‌نویسی به زبان اسمبلی رواج داشت، این مسئله وخیمتر شد. استفاده از کامپایلر، برنامه‌نویسی خودکار نامیده شد. طرفداران زبان‌های سطح بالا می‌ترسیدند که کد تولید شده نسبت به زبان اسمبلی کارایی چندان نداشته باشد. اولین کامپایلر فرترن (شریدان ۱۹۵۹) به خوبی بهینه‌سازی شد.

از ۱۹۶۰تا۱۹۷۵:تجزیه کردن

در دهه‌های ۱۹۶۰و۱۹۷۰ زبان‌های برنامه‌سازی جدید به وجود آمدند و طراحان زبان معتقد بودند که طراحی سریع کامپایلر برای زبان جدید، مهم‌تر از وجود کامپایلری با کد کارآمد است. بدین ترتیب، در ساخت کامپایلر به پردازشگر جلویی تأکید شده‌است. در همین زمان، مطالعه زبان‌های رسمی، تکنیک‌های قدرتمندی را برای ساخت پردازشگر جلوی، به‌خصوص تولید تجزیه‌کننده به وجود آورد.

از ۱۹۷۵ تاکنون:تولید کد و بهینه‌سازی کد

از ۱۹۷۵ تاکنون، تعداد زبان‌های جدید و انواع ماشین مختلف کاهش یافت در نتیجه نیاز به کامپایلرهای سریع و ساده یا سریع و ناقص برای زبان‌ها یا ماشین‌های جدید، کاهش یافت. بزرگ‌ترین آشفتگی در طراحی زبان و ماشین خاتمه یافت و افراد خواستار کامپایلرهای قابل اعتماد، کارآمد و با واسط کاربر مناسب شدند. بدین ترتیب، توجه کیفی به کد بیشتر شد زیرا با تغییر اندکی که در ساختار ماشین‌ها ایجاد می‌شود، طول عمر کدها افزایش می‌یابد. در همین دوره، مدلهایی در برنامه‌نویسی به وجود آمدند که برنامه‌نویسی تابعی، منطقی و توزیعی نمونه‌های از این مدل‌ها هستند، خواسته‌های زمان اجرای این زبان‌ها نسبت به زبان‌های دستور، افزایش یافت.

 انواع کامپایلرها 
راه‌های مختلفی جهت دسته‌بندی کامپایلرها وجود دارد مثلاً می‌توان آن‌ها را با توجه به ورودی، خروجی، ساختار داخلی یا رفتار زمان اجرای آن تقسیم‌بندی کرد.

 کامپایلرهای Native و cross 
اکثر کامپایلرها به دو دسته Native و Cross تقسیم می‌شوند. کامپایلرهایی که به منظور اجرای برنامه‌ها کدهای باینری را تولید می‌کنند، کامپایلرهایی با کد محلی یا Native گوییم چرا که تنها در کامپیوترهای یک نوع با سیستم‌عاملهای یکسان قابل به‌کارگیری است. از طرف دیگر ممکن است کامپایلرها کدهای باینری را تولید کنند که در سیستم‌های مختلف قابل اجرا باشد. به این دسته از کامپایلرها که وابستگی به سخت‌افزار ندارند، کامپایلرهای عبوری یا Cross گوییم. برای این نوع کامپایلرها تنها کافی است برای بار اول سخت‌افزار را به آن معرفی نمود؛ بنابراین می‌توان نتیجه گرفت که کامپایلرهای عبوری مفیدتر هستند.
این تقسیم‌بندی برای مفسرها به کار نمی‌رود زیرا آن‌ها از نمایش دودویی برای اجرای کد خود استفاده نمی‌کنند.
ماشین‌های مجازی در هیچ‌یک از این دسته‌بندی‌ها نمی‌گنجد. هر گاه در ماشین‌های مجازی یکسان قابل اجرا باشد می‌توان آن را Native و هرگاه کامپایلر قادر به تولید خروجی برای پلت فورم‌های مختلف باشد آن را Cross گوییم.

 کامپایلرهای تک فاز و چند فاز 
فازبندی کامپایلرها که در پشت زمینه به محدودیت‌های منابع سخت‌افزاری وابسته‌است. در نتیجه کامپایلرها به مجموعه برنامه‌های کوچکتر تقسیم می‌شوند هر یک بخشی از عمل ترجمه یا آنالیز را برعهده می‌گیرند.
کامپایل تک فازی به نظر مفید می‌آید، چراکه سریعتر است. زبان پاسکال از این امکان استفاده می‌کند. اما مشکل اینجا است که اگر اعلان جلوتر از دستور به‌کارگیری باشد، چه کار باید کرد؟ برای حل این مشکل می‌توان در فاز اول اعلان‌ها را مشخص کرد و در فاز بعد عمل ترجمه را انجام داد. عیب دیگر کامپایلر تک فازی دشواری بهینه‌سازی کدهای زبان سطح بالا می‌باشد.
همگردان یک‌گذره (One-Pass Compiler) کامپایلری است که برای تولید کد ماشین، تنها یک مرتبه متن برنامه را می‌خواند. دستور برخی زبان‌ها به گونه‌ای است که تولید همگردان یک‌گذره برای آن‌ها غیرممکن است.
مجموعه همگردان‌های گنو یا Gnu complier colection یا به صورت مخفف GCC مجموعه‌ای از همگردان‌های آزاد برای زبان‌های برنامه‌نویسی است.
تقسم بندی کامپایلرها به برنامه‌های کوچکتر تکنیکی است که همچنان مورد بحث محققان است.
در این نوع دسته‌بندی کامپایلرها، انواع دیگری نیز وجود دارد:
 کامپایلر مبدأ به مبدأ که کدی با زبان سطح بالا را دریافت می‌کند و خروجی آن نیز زبان سطح بالا می‌باشد. مثلاً موازی‌سازی خودکار کامپایلر در مواردی که به‌طور تکراری در برنامه ورودی وجود دارد و سپس تغییر شکل‌دادن کد و نوشتن کد یا ساختار زبانی موازی (برابر) با آن. (همچون دستور DOALL در فورترن).
 کامپایلر Stage که به زبان اسمبلی برای ماشین نظری ترجمه می‌کند. مثلاً در پرولوگ
 ماشین پرولوگ معمولاً ماشین انتزاعی (WAM) خوانده می‌شود. بایت کدهای جاوا و Python زیر مجموعه‌ای از این دسته‌اند.
 کامپایلر زمان اجرا، برای سیستم‌های Smalltalk, Java و زبان‌های میانه(CIL) در محصولات NET. استفاده می‌شود.

 زبان‌های تفسیری و کامپایلی(m.h.sزبان ماشیی 
بسیاری از افراد زبان‌های سطح بالا (m.h.sزبان ماشیی) را به دو دسته تفسیری و کامپایلی تقسیم می‌کنند. کامپایلرها و مفسرها روی زبان‌ها عمل می‌کنند نه زبان‌ها روی آنها! مثلاً این تصور وجود دارد که الزاماً BASIC تفسیر می‌شود و C کامپایل. اما ممکن است نمونه‌هایی از BASIC یا C ارائه شود که به ترتیب کامپایلری و تفسیری باشد.
البته استثناهایی نیز وجود دارد، مثلاً برخی زبان‌ها در خصوصیات خود این تقسیم‌بندی را مشخص کرده‌اند(C کامپایلری است یا SNOBOL۴ و اکثر زبانهای اسکریپتی که کد منبع زمان اجرا دارند تفسیری می‌باشد).

 طراحی کامپایلرها 
تقسیم‌بندی پروسه‌های کامپایل به مجموعه‌ای از فازها مورد حمایت پروژه کامپایلری ((تولید کامپایلرهای باکیفیت))(PQCC) از دانشگاه Carnegie Mellon قرار گرفت. در این پروژه اصطلاحات جلو بندی، میان بندی (امروزه به ندرت به کار می‌رود) و عقب بندی معرفی شد.
اکثر کامپایلرهای امروزی بیش از دو فاز دارند. جلوبندی معمولاً با پردازش املایی و معنایی شرح داده می‌شود. عقب بندی شامل تبدیل نوع و بهینه‌سازی‌های مختلف می‌باشد. سپس کد برای آن کامپیوتر خاص تولید می‌شود.
استفاده از جلوبندی و عقب بندی این را ممکن می‌کند که جلوبندی‌های مختلفی برای زبان‌های مختلف وجود داشته باشد و عقب بندی‌های مختلفی نیز برای CPUهای مختلف.

 جلو بندی 
جلوبندی به منظور تولید کد میانی یا IR از کد مبدأ استفاده می‌شود. جلوبندی معمولاً جدول نمادها را مدیریت نموده و یک نگاشت گر ساختمان داده‌ای، هر نماد را از درون کد مبدأ به اطلاعات مربوط به آن مثل نوع و دامنه تعریف آن نگاشت خطی می‌شود. این امر در چند فاز انجام می‌گردد:
 خط نوسازی. زبان‌هایی که اجازه تعیین فضای اختیاری برای شناسه‌ها را می‌دهند قبل از عمل تجزیه نیاز به فاز اضافی دارند که کد ورودی را به صورت متعارفی برای تجزیه گر آماده کند. Algol, Coral66, Atlas Autocode وImp نمونه‌هایی از این زبانه هستند که به خط نوسازی (Line Reconstruction) نیازمند است.
 پیش پردازش. برخی زبان‌ها همچون C احتیاج به فاز پیش پردازش برای جایگزینی شروط کامپایل و ماکروها دارند. در زبان C فاز پیش پردازش شامل مرحله تحلیل لغوی می‌شود.
 تحلیل لغوی کد متنی مبدأ را به اجزای کوچکی که نشانه(token) نامیده می‌شود می‌شکند. هر نشانه واحد ساده‌ای از زبان است مثل کلمات کلیدی و نام نمادها. نحو نشانه‌ها نوعاً یک زبان باقاعده است، بنابراین یک ماشین حالت متناهی که برپایه یک عبارت باقاعده بنا می‌شود می‌تواند جهت شناخت آن استفاده شود.
 تحلیل نحوی شامل تجزیه کردن نشانه‌های مرتب جهت شناخت ساختار نحوی زبان می‌باشد.
 تحلیل معنایی فازی است که معنای برنامه را جهت رعایت قوانین زبان بررسی می‌کند. یک مثال برای این فاز کنترل نوع است.

 عقب بندی 
گاهی مرحله عقب بندی با مرحله تولید کد اشتباه گرفته می‌شود. اما می‌توان گفت که عقب بندی به مراحل چند گانه زیر تقسیم می‌شود:
 تحلیل کامپایلر: این پروسه برای بدست آوردن اطلاعات بیشتر از نمایش میانی فایل‌های ورودی می‌باشد. تحلیلگر نوعی تعاریف مختلفی دارد همچون تحلیلگر حلقوی، تحلیلگر وابسته، تحلیلگر مستعار، تحلیلگر اشاره‌ای یا غیره می‌باشد. تحلیل دقیق زیر بنای هر کامپایلرهای بهینه‌است. گراف فراخوانی و نمودار جریان کنترل معمولاً در فاز تجزیه تولید می‌گردد.
 بهینه‌سازی: نمایش میانی زبان به معادل‌های پر سرعت تر با شکل‌های کوتاه تری تبدیل می‌گردد. از بهینه‌سازهای محبوبتر می‌توان به موارد زیر اشاره نمود: توسعه درون خطی، حذف کدهای مرده، انتشار ثوابت، تبدیل حلقهها، تخصیص‌های ثباتی و موازی‌سازی خودکار.
 تولیدکننده کد: زبان میانی تغییر کرده به زبان خروجی مثل زبان ماشین ترجمه می‌شود. این شامل تخصیص منابع و تصمیمات ذخیره‌سازی است، مثلاً اینکه کدام متغیر به رجیسترها یا حافظه اختصاص یابد و گزینش و زمانبندی دستورهای مناسب ماشین.

«البته در ابتدای امر که دربارهٔ زبان‌های تفسیری و کامپایلری گفته بودند باید خاطر نشان کرد که زبان‌های تفسیری خط به خط خوانده شده و اجرا می‌گردد در حالیکه در کامپایلری ابتدا تمام برنامه ترجمه شده و سپس اجرا می‌گردد پس در زمان اجرا سرعت اجرا شدن زبان‌های کامپایلری بیشتر است. اما کشف و تصحیح خطا در تفسیری بهتر و راحت تر است.»

 همگردان‌های نمونه 
 مجموعه همگردان گنو 
GCC از ابتدا مخفف Gnu C Compiler بود ولی از زمانی که توانست زبان‌های دیگری غیر از C از قبیل C++,Ada,Java,Objective C و Fortran را کامپایل کند به Gnu Compiler Collection تغییر نام داد.
پدید آورنده اصلی GCC ریچارد استالمن است کسی که بنیان‌گذار پروژه Gnu محسوب می‌شود. نخستین نسخه GCC در سال ۱۹۸۷ انتشار یافت که یک پیشرفت مهم محسوب می‌شد زیرا محصول جدید اولین کامپایلر بهینه‌سازی شده قابل حمل ANSI C به عنوان یک نرم‌افزار آزاد محسوب می‌شد.
در سال ۱۹۹۲ نسخه ۲٫۰ کامپایلر GCC عرضه شد. نسخه جدید قابلیت کامپایل کدهای ++C را نیز داشت.
در سال ۱۹۹۷ یک انشعاب آزمایشی در GCC به نام EGCC به منظور بهینه‌سازی کامپایلر و پشتیبانی کامل تر از ++C ایجاد شد. در ادامه EGCC به عنوان نسل بعدی کامپایلر GCC پذیرفته شد و تکامل آن باعث انتشار نسخه سوم GCC در سال ۲۰۰۴ گردید.
چهارمین نسخه از کامپایلر GCC در سال ۲۰۰۵ عرضه شد.

 جستارهای وابسته 
 اختراع‌ها در ایالات متحده (۱۹۴۶–۱۹۹۱)
 گرامرهای عبارت قطعی
ترجمه دوگانه

 منابع 

 ویکی‌پدیای انگلیسی

رده:اختراع‌های آمریکایی
رده:انواع نرم‌افزارهای کاربردپذیری
رده:برنامه‌نویسی
رده:پیاده‌سازی زبان برنامه‌نویسی
رده:کامپایلرسازی
رده:کامپایلرها
رده:کتابخانه‌های رایانه